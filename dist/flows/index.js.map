{"version":3,"sources":["../../src/flows/FlowBuilder.ts","../../src/flows/FlowExecutor.ts","../../src/flows/converters.ts","../../src/flows/inputs.ts","../../src/flows/validators.ts"],"names":["nanoid","variables","expression","z"],"mappings":"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","file":"index.js","sourcesContent":["import { nanoid } from 'nanoid';\nimport { EditorStep, AgentFlow, FlowInputVariable } from '../types';\n\n/**\n * FlowBuilder\n * Fluent API for building flow definitions\n */\nexport class FlowBuilder {\n  private flow: Partial<AgentFlow> = {};\n\n  /**\n   * Set flow ID\n   */\n  public setId(id: string): this {\n    this.flow.id = id;\n    return this;\n  }\n\n  /**\n   * Set flow code (unique identifier)\n   */\n  public setCode(code: string): this {\n    this.flow.code = code;\n    return this;\n  }\n\n  /**\n   * Set flow name\n   */\n  public setName(name: string): this {\n    this.flow.name = name;\n    return this;\n  }\n\n  /**\n   * Set flow description\n   */\n  public setDescription(description: string): this {\n    this.flow.description = description;\n    return this;\n  }\n\n  /**\n   * Add an input variable\n   */\n  public addInput(input: FlowInputVariable): this {\n    if (!this.flow.inputs) {\n      this.flow.inputs = [];\n    }\n    this.flow.inputs.push(input);\n    return this;\n  }\n\n  /**\n   * Set all input variables\n   */\n  public setInputs(inputs: FlowInputVariable[]): this {\n    this.flow.inputs = inputs;\n    return this;\n  }\n\n  /**\n   * Set the flow definition\n   */\n  public setFlow(flow: EditorStep): this {\n    this.flow.flow = flow;\n    return this;\n  }\n\n  /**\n   * Add an agent definition\n   */\n  public addAgent(agent: any): this {\n    if (!this.flow.agents) {\n      this.flow.agents = [];\n    }\n    this.flow.agents.push(agent);\n    return this;\n  }\n\n  /**\n   * Set all agents\n   */\n  public setAgents(agents: any[]): this {\n    this.flow.agents = agents;\n    return this;\n  }\n\n  /**\n   * Build the flow\n   */\n  public build(): AgentFlow {\n    this.validate();\n\n    return {\n      id: this.flow.id || nanoid(),\n      code: this.flow.code!,\n      name: this.flow.name!,\n      description: this.flow.description,\n      inputs: this.flow.inputs || [],\n      flow: this.flow.flow,\n      agents: this.flow.agents || [],\n    };\n  }\n\n  /**\n   * Validate the flow configuration\n   */\n  private validate(): void {\n    if (!this.flow.code) {\n      throw new Error('Flow code is required');\n    }\n    if (!this.flow.name) {\n      throw new Error('Flow name is required');\n    }\n\n    // Validate input variables\n    if (this.flow.inputs) {\n      const names = new Set<string>();\n      for (const input of this.flow.inputs) {\n        if (!input.name) {\n          throw new Error('Input variable name is required');\n        }\n        if (names.has(input.name)) {\n          throw new Error(`Duplicate input variable name: ${input.name}`);\n        }\n        names.add(input.name);\n      }\n    }\n  }\n\n  /**\n   * Create a builder from existing flow\n   */\n  public static from(flow: AgentFlow): FlowBuilder {\n    const builder = new FlowBuilder();\n    builder.flow = { ...flow };\n    return builder;\n  }\n\n  /**\n   * Create a new builder instance\n   */\n  public static create(): FlowBuilder {\n    return new FlowBuilder();\n  }\n}\n","/**\n * Flow Executor\n * Executes flow-based agents with full LLM and tool integration\n */\n\nimport { LLMProvider, Message } from '../providers';\nimport { ToolRegistry } from '../tools';\nimport { AgentFlow, EditorStep } from '../types';\nimport { AgentConfig } from '../types';\n\n/**\n * Flow execution context\n */\nexport interface FlowExecutionContext {\n  agent: AgentConfig;\n  session?: any;\n  variables: Record<string, any>;\n  provider: LLMProvider;\n  toolRegistry?: ToolRegistry;\n  memory?: any[];\n  maxDepth?: number;\n  currentDepth?: number;\n}\n\n/**\n * Flow execution event types\n */\nexport type FlowExecutionEventType =\n  | 'flow-start'\n  | 'flow-complete'\n  | 'flow-error'\n  | 'step-start'\n  | 'step-complete'\n  | 'step-error'\n  | 'variable-set'\n  | 'llm-call'\n  | 'llm-response'\n  | 'tool-call'\n  | 'tool-result'\n  | 'condition-evaluated'\n  | 'loop-iteration';\n\n/**\n * Flow execution event\n */\nexport interface FlowExecutionEvent {\n  type: FlowExecutionEventType;\n  timestamp: Date;\n  stepId?: string;\n  stepType?: string;\n  data?: any;\n  variables?: Record<string, any>;\n  error?: Error;\n}\n\n/**\n * Flow execution result\n */\nexport interface FlowExecutionResult {\n  success: boolean;\n  output: any;\n  variables: Record<string, any>;\n  steps: number;\n  events: FlowExecutionEvent[];\n  error?: Error;\n}\n\n/**\n * Flow Executor\n */\nexport class FlowExecutor {\n  /**\n   * Execute a flow\n   */\n  static async execute(\n    flow: AgentFlow,\n    context: FlowExecutionContext,\n    onEvent?: (event: FlowExecutionEvent) => void\n  ): Promise<FlowExecutionResult> {\n    const events: FlowExecutionEvent[] = [];\n    const variables = { ...context.variables };\n    let steps = 0;\n\n    // Emit flow start event\n    const startEvent: FlowExecutionEvent = {\n      type: 'flow-start',\n      timestamp: new Date(),\n      data: { flowCode: flow.code, flowName: flow.name },\n    };\n    events.push(startEvent);\n    onEvent?.(startEvent);\n\n    try {\n      // Execute the flow\n      const output = await this.executeNode(\n        flow.flow,\n        { ...context, variables, currentDepth: 0 },\n        events,\n        onEvent\n      );\n      steps = events.filter(e => e.type === 'step-complete').length;\n\n      // Emit flow complete event\n      const completeEvent: FlowExecutionEvent = {\n        type: 'flow-complete',\n        timestamp: new Date(),\n        data: { output, steps },\n        variables,\n      };\n      events.push(completeEvent);\n      onEvent?.(completeEvent);\n\n      return {\n        success: true,\n        output,\n        variables,\n        steps,\n        events,\n      };\n    } catch (error) {\n      // Emit flow error event\n      const errorEvent: FlowExecutionEvent = {\n        type: 'flow-error',\n        timestamp: new Date(),\n        error: error as Error,\n      };\n      events.push(errorEvent);\n      onEvent?.(errorEvent);\n\n      return {\n        success: false,\n        output: null,\n        variables,\n        steps: events.filter(e => e.type === 'step-complete').length,\n        events,\n        error: error as Error,\n      };\n    }\n  }\n\n  /**\n   * Execute a single flow node\n   */\n  private static async executeNode(\n    node: EditorStep | any,\n    context: FlowExecutionContext,\n    events: FlowExecutionEvent[],\n    onEvent?: (event: FlowExecutionEvent) => void\n  ): Promise<any> {\n    // Check depth to prevent infinite recursion\n    const maxDepth = context.maxDepth || 100;\n    const currentDepth = context.currentDepth || 0;\n    if (currentDepth > maxDepth) {\n      throw new Error(`Maximum flow depth ${maxDepth} exceeded`);\n    }\n\n    const stepId = (node as any).id || `step-${Date.now()}`;\n\n    // Emit step start event\n    const startEvent: FlowExecutionEvent = {\n      type: 'step-start',\n      timestamp: new Date(),\n      stepId,\n      stepType: node.type,\n    };\n    events.push(startEvent);\n    onEvent?.(startEvent);\n\n    try {\n      let result: any;\n\n      switch (node.type) {\n        case 'sequence':\n          result = await this.executeSequence(node, context, events, onEvent);\n          break;\n        case 'parallel':\n          result = await this.executeParallel(node, context, events, onEvent);\n          break;\n        case 'oneOf':\n          result = await this.executeOneOf(node, context, events, onEvent);\n          break;\n        case 'forEach':\n          result = await this.executeForEach(node, context, events, onEvent);\n          break;\n        case 'evaluator':\n          result = await this.executeEvaluator(node, context, events, onEvent);\n          break;\n        case 'llmCall':\n          result = await this.executeLLMCall(node, context, events, onEvent);\n          break;\n        case 'toolCall':\n          result = await this.executeToolCall(node, context, events, onEvent);\n          break;\n        case 'setVariable':\n          result = await this.executeSetVariable(node, context, events, onEvent);\n          break;\n        case 'return':\n          result = this.executeReturn(node, context);\n          break;\n        case 'end':\n          result = this.executeEnd(node, context);\n          break;\n        case 'throw':\n          throw new Error(this.interpolate((node as any).message || 'Flow error', context.variables));\n        default:\n          throw new Error(`Unknown node type: ${(node as any).type}`);\n      }\n\n      // Emit step complete event\n      const completeEvent: FlowExecutionEvent = {\n        type: 'step-complete',\n        timestamp: new Date(),\n        stepId,\n        stepType: node.type,\n        data: result,\n      };\n      events.push(completeEvent);\n      onEvent?.(completeEvent);\n\n      return result;\n    } catch (error) {\n      // Emit step error event\n      const errorEvent: FlowExecutionEvent = {\n        type: 'step-error',\n        timestamp: new Date(),\n        stepId,\n        stepType: node.type,\n        error: error as Error,\n      };\n      events.push(errorEvent);\n      onEvent?.(errorEvent);\n\n      throw error;\n    }\n  }\n\n  /**\n   * Execute sequence node\n   */\n  private static async executeSequence(\n    node: any,\n    context: FlowExecutionContext,\n    events: FlowExecutionEvent[],\n    onEvent?: (event: FlowExecutionEvent) => void\n  ): Promise<any> {\n    const steps = node.steps || [];\n    let lastResult: any = null;\n\n    for (const step of steps) {\n      lastResult = await this.executeNode(\n        step,\n        { ...context, currentDepth: (context.currentDepth || 0) + 1 },\n        events,\n        onEvent\n      );\n    }\n\n    return lastResult;\n  }\n\n  /**\n   * Execute parallel node\n   */\n  private static async executeParallel(\n    node: any,\n    context: FlowExecutionContext,\n    events: FlowExecutionEvent[],\n    onEvent?: (event: FlowExecutionEvent) => void\n  ): Promise<any[]> {\n    const steps = node.steps || [];\n    \n    const results = await Promise.all(\n      steps.map((step: any) =>\n        this.executeNode(\n          step,\n          { ...context, currentDepth: (context.currentDepth || 0) + 1 },\n          events,\n          onEvent\n        )\n      )\n    );\n\n    return results;\n  }\n\n  /**\n   * Execute oneOf (conditional) node\n   */\n  private static async executeOneOf(\n    node: any,\n    context: FlowExecutionContext,\n    events: FlowExecutionEvent[],\n    onEvent?: (event: FlowExecutionEvent) => void\n  ): Promise<any> {\n    const options = node.options || [];\n\n    for (const option of options) {\n      // Evaluate condition if present\n      if (option.condition) {\n        const conditionMet = this.evaluateCondition(option.condition, context.variables);\n        \n        // Emit condition evaluated event\n        const conditionEvent: FlowExecutionEvent = {\n          type: 'condition-evaluated',\n          timestamp: new Date(),\n          data: { condition: option.condition, result: conditionMet },\n        };\n        events.push(conditionEvent);\n        onEvent?.(conditionEvent);\n\n        if (conditionMet) {\n          return await this.executeNode(\n            option.step,\n            { ...context, currentDepth: (context.currentDepth || 0) + 1 },\n            events,\n            onEvent\n          );\n        }\n      } else {\n        // Default option (no condition)\n        return await this.executeNode(\n          option.step,\n          { ...context, currentDepth: (context.currentDepth || 0) + 1 },\n          events,\n          onEvent\n        );\n      }\n    }\n\n    return null;\n  }\n\n  /**\n   * Execute forEach loop node\n   */\n  private static async executeForEach(\n    node: any,\n    context: FlowExecutionContext,\n    events: FlowExecutionEvent[],\n    onEvent?: (event: FlowExecutionEvent) => void\n  ): Promise<any[]> {\n    const items = this.resolveValue(node.items, context.variables) || [];\n    const itemVar = node.itemVariable || 'item';\n    const indexVar = node.indexVariable || 'index';\n    const results: any[] = [];\n\n    for (let i = 0; i < items.length; i++) {\n      // Set loop variables in the current context\n      context.variables[itemVar] = items[i];\n      context.variables[indexVar] = i;\n\n      // Emit loop iteration event\n      const iterationEvent: FlowExecutionEvent = {\n        type: 'loop-iteration',\n        timestamp: new Date(),\n        data: { item: items[i], index: i },\n      };\n      events.push(iterationEvent);\n      onEvent?.(iterationEvent);\n\n      // Execute step with updated context\n      if (node.step) {\n        const result = await this.executeNode(\n          node.step,\n          { ...context, currentDepth: (context.currentDepth || 0) + 1 },\n          events,\n          onEvent\n        );\n        results.push(result);\n      }\n    }\n\n    return results;\n  }\n\n  /**\n   * Execute evaluator node\n   */\n  private static async executeEvaluator(\n    node: any,\n    context: FlowExecutionContext,\n    events: FlowExecutionEvent[],\n    onEvent?: (event: FlowExecutionEvent) => void\n  ): Promise<any> {\n    const expression = node.expression || '';\n    return this.evaluateExpression(expression, context.variables);\n  }\n\n  /**\n   * Execute LLM call node\n   */\n  private static async executeLLMCall(\n    node: any,\n    context: FlowExecutionContext,\n    events: FlowExecutionEvent[],\n    onEvent?: (event: FlowExecutionEvent) => void\n  ): Promise<string> {\n    const prompt = this.interpolate(node.prompt || '', context.variables);\n    const model = node.model || context.agent.settings?.model || 'gpt-4';\n\n    // Build messages\n    const messages: Message[] = [];\n    \n    // Add system prompt if available\n    if (context.agent.prompt) {\n      messages.push({\n        role: 'system',\n        content: context.agent.prompt,\n      });\n    }\n\n    // Add user message\n    messages.push({\n      role: 'user',\n      content: prompt,\n    });\n\n    // Emit LLM call event\n    const callEvent: FlowExecutionEvent = {\n      type: 'llm-call',\n      timestamp: new Date(),\n      data: { model, prompt },\n    };\n    events.push(callEvent);\n    onEvent?.(callEvent);\n\n    // Call LLM\n    const result = await context.provider.generate({\n      model,\n      messages,\n      temperature: node.temperature,\n      maxTokens: node.maxTokens,\n    });\n\n    // Emit LLM response event\n    const responseEvent: FlowExecutionEvent = {\n      type: 'llm-response',\n      timestamp: new Date(),\n      data: { text: result.text, usage: result.usage },\n    };\n    events.push(responseEvent);\n    onEvent?.(responseEvent);\n\n    // Store result in variable if specified\n    if (node.outputVariable) {\n      context.variables[node.outputVariable] = result.text;\n      \n      const varEvent: FlowExecutionEvent = {\n        type: 'variable-set',\n        timestamp: new Date(),\n        data: { variable: node.outputVariable, value: result.text },\n      };\n      events.push(varEvent);\n      onEvent?.(varEvent);\n    }\n\n    return result.text;\n  }\n\n  /**\n   * Execute tool call node\n   */\n  private static async executeToolCall(\n    node: any,\n    context: FlowExecutionContext,\n    events: FlowExecutionEvent[],\n    onEvent?: (event: FlowExecutionEvent) => void\n  ): Promise<any> {\n    if (!context.toolRegistry) {\n      throw new Error('Tool registry not available');\n    }\n\n    const toolName = node.tool || '';\n    const toolDesc = context.toolRegistry.get(toolName);\n    \n    if (!toolDesc || !toolDesc.tool) {\n      throw new Error(`Tool '${toolName}' not found`);\n    }\n\n    // Interpolate arguments\n    const args = this.interpolateObject(node.arguments || {}, context.variables);\n\n    // Emit tool call event\n    const callEvent: FlowExecutionEvent = {\n      type: 'tool-call',\n      timestamp: new Date(),\n      data: { tool: toolName, arguments: args },\n    };\n    events.push(callEvent);\n    onEvent?.(callEvent);\n\n    // Execute tool\n    const result = toolDesc.tool.execute ? await toolDesc.tool.execute(args, {} as any) : null;\n\n    // Emit tool result event\n    const resultEvent: FlowExecutionEvent = {\n      type: 'tool-result',\n      timestamp: new Date(),\n      data: { tool: toolName, result },\n    };\n    events.push(resultEvent);\n    onEvent?.(resultEvent);\n\n    // Store result in variable if specified\n    if (node.outputVariable) {\n      context.variables[node.outputVariable] = result;\n      \n      const varEvent: FlowExecutionEvent = {\n        type: 'variable-set',\n        timestamp: new Date(),\n        data: { variable: node.outputVariable, value: result },\n      };\n      events.push(varEvent);\n      onEvent?.(varEvent);\n    }\n\n    return result;\n  }\n\n  /**\n   * Execute setVariable node\n   */\n  private static async executeSetVariable(\n    node: any,\n    context: FlowExecutionContext,\n    events: FlowExecutionEvent[],\n    onEvent?: (event: FlowExecutionEvent) => void\n  ): Promise<any> {\n    const variableName = node.variable || '';\n    const value = this.resolveValue(node.value, context.variables);\n\n    context.variables[variableName] = value;\n\n    const varEvent: FlowExecutionEvent = {\n      type: 'variable-set',\n      timestamp: new Date(),\n      data: { variable: variableName, value },\n    };\n    events.push(varEvent);\n    onEvent?.(varEvent);\n\n    return value;\n  }\n\n  /**\n   * Execute return node\n   */\n  private static executeReturn(\n    node: any,\n    context: FlowExecutionContext\n  ): any {\n    return this.resolveValue(node.value, context.variables);\n  }\n\n  /**\n   * Execute end node\n   */\n  private static executeEnd(\n    node: any,\n    context: FlowExecutionContext\n  ): any {\n    return this.resolveValue(node.value, context.variables);\n  }\n\n  /**\n   * Interpolate string with variables\n   */\n  private static interpolate(template: string, variables: Record<string, any>): string {\n    return template.replace(/\\{\\{(\\w+)\\}\\}/g, (_, key) => {\n      return variables[key]?.toString() || '';\n    });\n  }\n\n  /**\n   * Interpolate object with variables\n   */\n  private static interpolateObject(obj: any, variables: Record<string, any>): any {\n    if (typeof obj === 'string') {\n      return this.interpolate(obj, variables);\n    }\n    if (Array.isArray(obj)) {\n      return obj.map(item => this.interpolateObject(item, variables));\n    }\n    if (obj && typeof obj === 'object') {\n      const result: any = {};\n      for (const [key, value] of Object.entries(obj)) {\n        result[key] = this.interpolateObject(value, variables);\n      }\n      return result;\n    }\n    return obj;\n  }\n\n  /**\n   * Resolve a value (can be literal or variable reference)\n   */\n  private static resolveValue(value: any, variables: Record<string, any>): any {\n    if (typeof value === 'string' && value.startsWith('$')) {\n      const varName = value.substring(1);\n      return variables[varName];\n    }\n    return value;\n  }\n\n  /**\n   * Evaluate a condition\n   */\n  private static evaluateCondition(condition: string, variables: Record<string, any>): boolean {\n    try {\n      // Simple evaluation - supports basic comparisons\n      // In production, use a safe expression evaluator\n      const interpolated = this.interpolate(condition, variables);\n      return !!eval(interpolated);\n    } catch {\n      return false;\n    }\n  }\n\n  /**\n   * Evaluate an expression\n   */\n  private static evaluateExpression(expression: string, variables: Record<string, any>): any {\n    try {\n      const interpolated = this.interpolate(expression, variables);\n      return eval(interpolated);\n    } catch (error) {\n      throw new Error(`Failed to evaluate expression: ${expression}`);\n    }\n  }\n}\n","import { nanoid } from 'nanoid';\nimport { EditorStep } from '../types';\n\n/**\n * Convert EditorStep to flows-ai compatible FlowDefinition\n * This recursively transforms the internal EditorStep structure\n * to the format expected by the flows-ai execution engine\n */\nexport function convertToFlowDefinition(step: EditorStep): any {\n  switch (step.type) {\n    // ------------------------------------\n    // STEP - Basic agent execution\n    // ------------------------------------\n    case 'step':\n      return {\n        id: nanoid(),\n        agent: step.agent,\n        input: step.input,\n      };\n\n    // ------------------------------------\n    // SEQUENCE - Execute steps in order\n    // ------------------------------------\n    case 'sequence':\n      return {\n        id: nanoid(),\n        agent: 'sequenceAgent',\n        input: step.steps.map((child) => convertToFlowDefinition(child)),\n      };\n\n    // ------------------------------------\n    // PARALLEL - Execute steps concurrently\n    // ------------------------------------\n    case 'parallel':\n      return {\n        id: nanoid(),\n        agent: 'parallelAgent',\n        input: step.steps.map((child) => convertToFlowDefinition(child)),\n      };\n\n    // ------------------------------------\n    // ONE-OF - Conditional branching\n    // ------------------------------------\n    case 'oneOf':\n      const flows = step.branches.map((b) => convertToFlowDefinition(b.flow));\n      const conditions = step.branches.map((b) => b.when);\n      return {\n        id: nanoid(),\n        agent: 'oneOfAgent',\n        input: flows,\n        conditions: conditions,\n      };\n\n    // ------------------------------------\n    // FOR-EACH - Iterate over items\n    // ------------------------------------\n    case 'forEach':\n      return {\n        id: nanoid(),\n        agent: 'forEachAgent',\n        item: step.item,\n        input: convertToFlowDefinition(step.inputFlow),\n      };\n\n    // ------------------------------------\n    // EVALUATOR - Self-improvement loop\n    // ------------------------------------\n    case 'evaluator':\n      return {\n        id: nanoid(),\n        agent: 'optimizeAgent',\n        criteria: step.criteria,\n        max_iterations: step.max_iterations,\n        input: convertToFlowDefinition(step.subFlow),\n      };\n\n    // ------------------------------------\n    // BEST-OF-ALL - Run multiple and pick best\n    // ------------------------------------\n    case 'bestOfAll':\n      return {\n        id: nanoid(),\n        agent: 'bestOfAllAgent',\n        criteria: step.criteria,\n        input: step.steps.map((child) => convertToFlowDefinition(child)),\n      };\n\n    // ------------------------------------\n    // TOOL - Direct tool execution\n    // ------------------------------------\n    case 'tool':\n      return {\n        id: nanoid(),\n        agent: 'toolAgent',\n        input: JSON.stringify({\n          toolName: step.toolName,\n          toolOptions: step.toolOptions,\n        }),\n      };\n\n    // ------------------------------------\n    // UI-COMPONENT - UI rendering step\n    // ------------------------------------\n    case 'uiComponent':\n      return {\n        id: nanoid(),\n        agent: 'uiComponentAgent',\n        input: JSON.stringify({\n          componentName: step.componentName,\n          componentProps: step.componentProps,\n        }),\n      };\n\n    // ------------------------------------\n    // CONDITION - If-then-else\n    // ------------------------------------\n    case 'condition':\n      return {\n        id: nanoid(),\n        agent: 'oneOfAgent',\n        input: [\n          convertToFlowDefinition(step.trueFlow),\n          convertToFlowDefinition(step.falseFlow),\n        ],\n        conditions: [step.condition, `!(${step.condition})`],\n      };\n\n    // ------------------------------------\n    // LOOP - While loop\n    // ------------------------------------\n    case 'loop':\n      return {\n        id: nanoid(),\n        agent: 'forEachAgent',\n        item: 'iteration',\n        input: convertToFlowDefinition(step.loopFlow),\n        maxIterations: step.maxIterations,\n        condition: step.condition,\n      };\n\n    default:\n      return {\n        id: nanoid(),\n        agent: 'unknownAgent',\n        input: '',\n      };\n  }\n}\n\n/**\n * Convert flows-ai FlowDefinition back to EditorStep\n * Useful for round-tripping and editing\n */\nexport function convertFromFlowDefinition(flowDef: any): EditorStep {\n  const agent = flowDef.agent;\n\n  switch (agent) {\n    case 'sequenceAgent':\n      return {\n        type: 'sequence',\n        steps: Array.isArray(flowDef.input)\n          ? flowDef.input.map((child: any) => convertFromFlowDefinition(child))\n          : [],\n      };\n\n    case 'parallelAgent':\n      return {\n        type: 'parallel',\n        steps: Array.isArray(flowDef.input)\n          ? flowDef.input.map((child: any) => convertFromFlowDefinition(child))\n          : [],\n      };\n\n    case 'oneOfAgent':\n      const conditions = flowDef.conditions || [];\n      const flows = Array.isArray(flowDef.input) ? flowDef.input : [];\n      return {\n        type: 'oneOf',\n        branches: flows.map((flow: any, i: number) => ({\n          when: conditions[i] || '',\n          flow: convertFromFlowDefinition(flow),\n        })),\n      };\n\n    case 'forEachAgent':\n      return {\n        type: 'forEach',\n        item: flowDef.item || '',\n        inputFlow: convertFromFlowDefinition(flowDef.input),\n      };\n\n    case 'optimizeAgent':\n      return {\n        type: 'evaluator',\n        criteria: flowDef.criteria || '',\n        max_iterations: flowDef.max_iterations,\n        subFlow: convertFromFlowDefinition(flowDef.input),\n      };\n\n    case 'bestOfAllAgent':\n      return {\n        type: 'bestOfAll',\n        criteria: flowDef.criteria || '',\n        steps: Array.isArray(flowDef.input)\n          ? flowDef.input.map((child: any) => convertFromFlowDefinition(child))\n          : [],\n      };\n\n    case 'toolAgent':\n      try {\n        const parsed = JSON.parse(flowDef.input);\n        return {\n          type: 'tool',\n          toolName: parsed.toolName || '',\n          toolOptions: parsed.toolOptions || {},\n        };\n      } catch {\n        return {\n          type: 'step',\n          agent: 'toolAgent',\n          input: flowDef.input,\n        };\n      }\n\n    case 'uiComponentAgent':\n      try {\n        const parsed = JSON.parse(flowDef.input);\n        return {\n          type: 'uiComponent',\n          componentName: parsed.componentName || '',\n          componentProps: parsed.componentProps || {},\n        };\n      } catch {\n        return {\n          type: 'step',\n          agent: 'uiComponentAgent',\n          input: flowDef.input,\n        };\n      }\n\n    default:\n      return {\n        type: 'step',\n        agent: agent || 'defaultAgent',\n        input: typeof flowDef.input === 'string' ? flowDef.input : JSON.stringify(flowDef.input),\n      };\n  }\n}\n","import { z } from 'zod';\nimport { FlowInputVariable, FlowInputType } from '../types';\n\n/**\n * Extract variable names from a string in the format @variableName\n * Returns array of variable names without the @ prefix\n */\nexport function extractVariableNames(str: string): string[] {\n  const regex = /@([a-zA-Z0-9_]+)/g;\n  const result: string[] = [];\n  let match: RegExpExecArray | null;\n\n  while ((match = regex.exec(str)) !== null) {\n    result.push(match[1]);\n  }\n  return result;\n}\n\n/**\n * Replace all occurrences of @variableName with actual values\n */\nexport function replaceVariablesInString(\n  str: string,\n  variables: Record<string, string>\n): string {\n  let result = str;\n  for (const [name, value] of Object.entries(variables)) {\n    const pattern = new RegExp(`@${name}`, 'g');\n    result = result.replace(pattern, value);\n  }\n  return result;\n}\n\n/**\n * Inject variable values into a flow definition recursively\n */\nexport function injectVariables(\n  flowDef: any,\n  variables: Record<string, string>\n): any {\n  // Replace variables in string input\n  if (typeof flowDef.input === 'string') {\n    flowDef.input = replaceVariablesInString(flowDef.input, variables);\n  }\n\n  // Replace variables in conditions (oneOf)\n  if (Array.isArray(flowDef.conditions)) {\n    flowDef.conditions = flowDef.conditions.map((cond: string) =>\n      replaceVariablesInString(cond, variables)\n    );\n  }\n\n  // Replace variables in criteria (evaluator, bestOfAll)\n  if (typeof flowDef.criteria === 'string') {\n    flowDef.criteria = replaceVariablesInString(flowDef.criteria, variables);\n  }\n\n  // Recursively process nested flows\n  const agent = flowDef.agent;\n  switch (agent) {\n    case 'sequenceAgent':\n    case 'parallelAgent':\n    case 'bestOfAllAgent':\n    case 'oneOfAgent':\n      if (Array.isArray(flowDef.input)) {\n        flowDef.input.forEach((child: any) => injectVariables(child, variables));\n      }\n      break;\n\n    case 'forEachAgent':\n    case 'optimizeAgent':\n      if (flowDef.input && typeof flowDef.input === 'object') {\n        injectVariables(flowDef.input, variables);\n      }\n      break;\n  }\n\n  return flowDef;\n}\n\n/**\n * Apply transformation function to all input fields in flow definition\n */\nexport async function applyInputTransformation(\n  flowDef: any,\n  transformFn: (node: any) => Promise<any> | any\n): Promise<void> {\n  // Transform current node's input\n  flowDef.input = await transformFn(flowDef);\n  \n  // Set name if not present\n  if (!flowDef.name) {\n    flowDef.name = flowDef.agent;\n  }\n\n  // Recursively transform nested nodes\n  const agent = flowDef.agent;\n  switch (agent) {\n    case 'sequenceAgent':\n    case 'parallelAgent':\n    case 'bestOfAllAgent':\n    case 'oneOfAgent':\n      if (Array.isArray(flowDef.input)) {\n        await Promise.all(\n          flowDef.input.map((child: any) =>\n            applyInputTransformation(child, transformFn)\n          )\n        );\n      }\n      break;\n\n    case 'forEachAgent':\n    case 'optimizeAgent':\n      if (flowDef.input && typeof flowDef.input === 'object') {\n        await applyInputTransformation(flowDef.input, transformFn);\n      }\n      break;\n  }\n}\n\n/**\n * Create a dynamic Zod schema from flow input variables\n */\nexport function createDynamicZodSchemaForInputs(options: {\n  availableInputs: FlowInputVariable[];\n}): z.ZodObject<any> {\n  const { availableInputs } = options;\n\n  if (!availableInputs || availableInputs.length === 0) {\n    return z.object({});\n  }\n\n  const shape: Record<string, z.ZodTypeAny> = {};\n\n  for (const inputVar of availableInputs) {\n    let fieldSchema: z.ZodTypeAny;\n\n    switch (inputVar.type) {\n      case 'shortText':\n      case 'longText':\n      case 'url':\n        fieldSchema = z.string().describe(inputVar.description || inputVar.name);\n        break;\n\n      case 'number':\n        fieldSchema = z.number().describe(inputVar.description || inputVar.name);\n        break;\n\n      case 'json':\n        fieldSchema = z.any().describe(inputVar.description || inputVar.name);\n        break;\n\n      case 'fileBase64':\n        fieldSchema = z.string().describe(inputVar.description || inputVar.name);\n        break;\n\n      default:\n        fieldSchema = z.string().describe(inputVar.description || inputVar.name);\n    }\n\n    // Make optional if not required\n    if (!inputVar.required) {\n      fieldSchema = fieldSchema.optional();\n    }\n\n    shape[inputVar.name] = fieldSchema;\n  }\n\n  return z.object(shape);\n}\n\n/**\n * Validate flow input against schema\n */\nexport function validateFlowInput(\n  input: any,\n  variables: FlowInputVariable[]\n): { valid: boolean; errors: string[] } {\n  const errors: string[] = [];\n\n  for (const variable of variables) {\n    if (variable.required && (input[variable.name] === undefined || input[variable.name] === null)) {\n      errors.push(`Required input variable '${variable.name}' is missing`);\n    }\n\n    if (input[variable.name] !== undefined) {\n      const value = input[variable.name];\n\n      // Type validation\n      switch (variable.type) {\n        case 'number':\n          if (typeof value !== 'number') {\n            errors.push(`Input variable '${variable.name}' must be a number`);\n          }\n          break;\n\n        case 'shortText':\n        case 'longText':\n        case 'url':\n        case 'fileBase64':\n          if (typeof value !== 'string') {\n            errors.push(`Input variable '${variable.name}' must be a string`);\n          }\n          break;\n\n        case 'json':\n          // Any type is acceptable\n          break;\n      }\n    }\n  }\n\n  return {\n    valid: errors.length === 0,\n    errors,\n  };\n}\n\n/**\n * Input type labels for UI display\n */\nexport const INPUT_TYPE_LABELS: Record<FlowInputType, string> = {\n  shortText: 'Short text',\n  url: 'URL',\n  longText: 'Long text',\n  number: 'Number',\n  json: 'JSON Object',\n  fileBase64: 'File (Base64)',\n};\n","import { AgentFlow, FlowAgentDefinition } from '../types';\n\n/**\n * Validate flow configuration\n */\nexport function validateFlow(flow: Partial<AgentFlow>): {\n  valid: boolean;\n  errors: string[];\n} {\n  const errors: string[] = [];\n\n  if (!flow.code) {\n    errors.push('Flow code is required');\n  }\n\n  if (!flow.name) {\n    errors.push('Flow name is required');\n  }\n\n  // Validate input variables\n  if (flow.inputs) {\n    const names = new Set<string>();\n    for (const input of flow.inputs) {\n      if (!input.name) {\n        errors.push('Input variable name is required');\n      } else {\n        if (names.has(input.name)) {\n          errors.push(`Duplicate input variable name: ${input.name}`);\n        }\n        names.add(input.name);\n      }\n\n      if (!input.type) {\n        errors.push(`Input variable '${input.name}' must have a type`);\n      }\n    }\n  }\n\n  // Validate agents\n  if (flow.agents) {\n    const agentNames = new Set<string>();\n    for (const agent of flow.agents) {\n      if (!agent.name) {\n        errors.push('Agent name is required');\n      } else {\n        if (agentNames.has(agent.name)) {\n          errors.push(`Duplicate agent name: ${agent.name}`);\n        }\n        agentNames.add(agent.name);\n      }\n\n      if (!agent.model) {\n        errors.push(`Agent '${agent.name}' must have a model specified`);\n      }\n\n      if (!agent.system) {\n        errors.push(`Agent '${agent.name}' must have a system prompt`);\n      }\n    }\n  }\n\n  return {\n    valid: errors.length === 0,\n    errors,\n  };\n}\n\n/**\n * Validate agent definition\n */\nexport function validateAgentDefinition(agent: Partial<FlowAgentDefinition>): {\n  valid: boolean;\n  errors: string[];\n} {\n  const errors: string[] = [];\n\n  if (!agent.name) {\n    errors.push('Agent name is required');\n  }\n\n  if (!agent.model) {\n    errors.push('Agent model is required');\n  }\n\n  if (!agent.system) {\n    errors.push('Agent system prompt is required');\n  }\n\n  return {\n    valid: errors.length === 0,\n    errors,\n  };\n}\n"]}