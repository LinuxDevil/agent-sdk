{"version":3,"sources":["../src/core/ConfigManager.ts","../src/types/common.ts","../src/types/agent.ts","../src/types/flow.ts","../src/agent-types/registry.ts","../src/agent-types/validators.ts","../src/core/AgentBuilder.ts","../src/tools/ToolRegistry.ts","../src/tools/built-in/currentDate.ts","../src/tools/built-in/dayName.ts","../src/tools/built-in/http.ts","../src/tools/built-in/email.ts","../src/flows/FlowBuilder.ts","../src/flows/FlowExecutor.ts","../src/flows/converters.ts","../src/flows/inputs.ts","../src/flows/validators.ts","../src/data/models.ts","../src/data/mocks.ts","../src/providers/llm.ts","../src/providers/mock.ts","../src/providers/OpenAIProvider.ts","../src/providers/OllamaProvider.ts","../src/providers/index.ts","../src/execution/AgentExecutor.ts","../src/execution/MemoryManager.ts","../src/execution/ContextBuilder.ts","../src/execution/errors.ts","../src/execution/retry.ts","../src/security/crypto.ts","../src/security/quotas.ts","../src/storage/StorageService.ts","../src/templates/TemplateManager.ts","../src/utils/json-path.ts","../src/utils/errors.ts","../src/utils/formatters.ts","../src/utils/validators.ts","../src/utils/file-extractor.ts","../src/index.ts"],"names":["DataLoadingStatus","AgentType","FlowChunkType","tool","z","nanoid","variables","expression","aiTool","chunk","convertMessages","generateText","streamText"],"mappings":"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","file":"index.mjs","sourcesContent":["/**\n * SDK Configuration\n */\nexport interface SDKConfig {\n  databaseIdHash: string;\n  storageKey?: string;\n  llm?: {\n    provider: 'openai' | 'ollama' | string;\n    apiKey?: string;\n    model?: string;\n    baseUrl?: string;\n  };\n  storage?: {\n    provider: string;\n    options?: Record<string, any>;\n  };\n  security?: {\n    encryption?: boolean;\n    encryptionKey?: string;\n  };\n}\n\n/**\n * Configuration manager for SDK\n */\nexport class ConfigManager {\n  private config: SDKConfig;\n\n  constructor(config: SDKConfig) {\n    this.validate(config);\n    this.config = config;\n  }\n\n  /**\n   * Get configuration\n   */\n  public getConfig(): SDKConfig {\n    return { ...this.config };\n  }\n\n  /**\n   * Update configuration\n   */\n  public updateConfig(updates: Partial<SDKConfig>): void {\n    this.config = { ...this.config, ...updates };\n    this.validate(this.config);\n  }\n\n  /**\n   * Get specific config value\n   */\n  public get<K extends keyof SDKConfig>(key: K): SDKConfig[K] {\n    return this.config[key];\n  }\n\n  /**\n   * Validate configuration\n   */\n  private validate(config: SDKConfig): void {\n    if (!config.databaseIdHash) {\n      throw new Error('databaseIdHash is required in SDK configuration');\n    }\n  }\n}\n","/**\n * Common types used throughout the SDK\n */\n\nexport enum DataLoadingStatus {\n  Idle = 'idle',\n  Loading = 'loading',\n  Success = 'success',\n  Error = 'error',\n}\n\nexport interface PaginationParams {\n  page?: number;\n  perPage?: number;\n}\n\nexport interface PaginatedResponse<T> {\n  data: T[];\n  total: number;\n  page: number;\n  perPage: number;\n  hasMore: boolean;\n}\n\nexport type DeepPartial<T> = {\n  [P in keyof T]?: T[P] extends object ? DeepPartial<T[P]> : T[P];\n};\n\nexport interface Timestamped {\n  createdAt: string;\n  updatedAt: string;\n}\n\nexport interface IdEntity {\n  id?: string | number;\n}\n","import { CoreMessage } from 'ai';\nimport { ToolConfiguration } from './tool';\nimport { AgentFlow } from './flow';\n\n/**\n * Agent type identifiers\n */\nexport enum AgentType {\n  SmartAssistant = 'smart-assistant',\n  SurveyAgent = 'survey-agent',\n  CommerceAgent = 'commerce-agent',\n  Flow = 'flow',\n}\n\n/**\n * Agent type descriptor\n */\nexport interface AgentTypeDescriptor {\n  type: AgentType;\n  description: Record<string, string>;\n  requiredTabs: string[];\n  supportsUserFacingUI: boolean;\n  displayName: Record<string, string>;\n}\n\n/**\n * Agent configuration\n */\nexport interface AgentConfig {\n  id?: string;\n  name: string;\n  agentType: AgentType;\n  locale?: string;\n  prompt?: string;\n  expectedResult?: any;\n  tools?: Record<string, ToolConfiguration>;\n  flows?: AgentFlow[];\n  events?: any[];\n  settings?: Record<string, any>;\n  metadata?: Record<string, any>;\n}\n\n/**\n * Agent execution options\n */\nexport interface AgentExecutionOptions {\n  streaming?: boolean;\n  sessionId: string;\n  messages: CoreMessage[];\n  attachments?: any[];\n  locale?: string;\n  timezone?: string;\n  currentDateTime?: string;\n}\n\n/**\n * Agent execution result\n */\nexport interface AgentExecutionResult {\n  success: boolean;\n  result?: any;\n  error?: string;\n  sessionId: string;\n  tokensUsed?: number;\n  duration?: number;\n}\n\n/**\n * Agent definition for flows\n */\nexport interface AgentDefinition {\n  name: string;\n  id?: string;\n  model: string;\n  system: string;\n  tools: ToolSetting[];\n}\n\n/**\n * Tool setting in agent definition\n */\nexport interface ToolSetting {\n  name: string;\n  options: any;\n}\n","/**\n * Flow chunk event types\n */\nexport enum FlowChunkType {\n  FlowStart = 'flowStart',\n  FlowStepStart = 'flowStepStart',\n  FlowFinish = 'flowFinish',\n  Generation = 'generation',\n  GenerationEnd = 'generationEnd',\n  ToolCalls = 'toolCalls',\n  TextStream = 'textStream',\n  FinalResult = 'finalResult',\n  Error = 'error',\n  Message = 'message',\n  UIComponent = 'uiComponent',\n}\n\n/**\n * Flow chunk event\n */\nexport interface FlowChunkEvent {\n  type: FlowChunkType;\n  flowNodeId?: string;\n  flowAgentId?: string;\n  duration?: number;\n  name?: string;\n  timestamp?: Date;\n  issues?: any[];\n  result?: string | string[];\n  message?: string;\n  input?: any;\n  toolResults?: Array<{\n    args?: any;\n    result?: string;\n  }>;\n  messages?: Array<{\n    role: string;\n    content: Array<{ type: string; text: string }>;\n    id?: string;\n  }>;\n  component?: string;\n  componentProps?: any;\n  replaceFlowNodeId?: string;\n  deleteFlowNodeId?: string;\n}\n\n/**\n * Flow input types\n */\nexport type FlowInputType =\n  | 'shortText'\n  | 'url'\n  | 'longText'\n  | 'number'\n  | 'json'\n  | 'fileBase64';\n\n/**\n * Flow input variable\n */\nexport interface FlowInputVariable {\n  name: string;\n  description?: string;\n  required: boolean;\n  type: FlowInputType;\n}\n\n/**\n * Tool setting for flows\n */\nexport interface FlowToolSetting {\n  name: string;\n  options: any;\n}\n\n/**\n * Agent definition for flows\n */\nexport interface FlowAgentDefinition {\n  name: string;\n  id?: string;\n  model: string;\n  system: string;\n  tools: FlowToolSetting[];\n}\n\n/**\n * Agent flow definition\n */\nexport interface AgentFlow {\n  id?: string;\n  code: string;\n  name: string;\n  description?: string;\n  inputs?: FlowInputVariable[];\n  flow?: EditorStep;\n  agents?: FlowAgentDefinition[];\n}\n\n/**\n * Flow execution mode\n */\nexport type FlowExecutionMode = 'sync' | 'async';\n\n/**\n * Flow output mode\n */\nexport type FlowOutputMode = 'stream' | 'buffer';\n\n/**\n * Editor step types\n */\nexport type EditorStep =\n  | StepNode\n  | SequenceNode\n  | ParallelNode\n  | OneOfNode\n  | ForEachNode\n  | EvaluatorNode\n  | BestOfAllNode\n  | ToolNode\n  | UIComponentNode\n  | ConditionNode\n  | LoopNode;\n\nexport interface StepNode {\n  type: 'step';\n  agent: string;\n  input: string;\n}\n\nexport interface SequenceNode {\n  type: 'sequence';\n  steps: EditorStep[];\n}\n\nexport interface ParallelNode {\n  type: 'parallel';\n  steps: EditorStep[];\n}\n\nexport interface OneOfNode {\n  type: 'oneOf';\n  branches: {\n    when: string;\n    flow: EditorStep;\n  }[];\n}\n\nexport interface ForEachNode {\n  type: 'forEach';\n  item: string;\n  inputFlow: EditorStep;\n}\n\nexport interface EvaluatorNode {\n  type: 'evaluator';\n  criteria: string;\n  max_iterations?: number;\n  subFlow: EditorStep;\n}\n\nexport interface BestOfAllNode {\n  type: 'bestOfAll';\n  criteria: string;\n  steps: EditorStep[];\n}\n\nexport interface ToolNode {\n  type: 'tool';\n  toolName: string;\n  toolOptions: Record<string, any>;\n}\n\nexport interface UIComponentNode {\n  type: 'uiComponent';\n  componentName: string;\n  componentProps: Record<string, any>;\n}\n\nexport interface ConditionNode {\n  type: 'condition';\n  condition: string;\n  trueFlow: EditorStep;\n  falseFlow: EditorStep;\n}\n\nexport interface LoopNode {\n  type: 'loop';\n  maxIterations: number;\n  condition: string;\n  loopFlow: EditorStep;\n}\n","import { AgentType, AgentTypeDescriptor } from '../types';\n\n/**\n * Agent types registry\n * Contains all available agent type descriptors\n */\nexport const agentTypesRegistry: AgentTypeDescriptor[] = [\n  {\n    type: AgentType.SmartAssistant,\n    description: {\n      pl: \"Inteligentni asystenci to **agenci oglnego przeznaczenia**. Mog korzysta z narzdzi, na przykad sprawdzajc Twj kalendarz lub rezerwujc nowe wydarzenia. Mog by rwnie uywane do ankiet (mieszane z innymi zadaniami), ale musz by dostosowane do tego na poziomie promptu.\",\n      en: \"Smart assistants are **general-purpose agents**. They can use tools, for example, checking your calendar or booking new events. They can also be used for surveys (mixed with other tasks) but need to be fine-tuned for doing so at the prompt level.\"    \n    },\n    supportsUserFacingUI: true,\n    requiredTabs: ['prompt', 'expectedResult'],\n    displayName: {\n      'pl': 'Inteligentny asystent [Chat]',\n      'en': 'Smart assistant [Chat]'\n    }\n  },    \n  {\n    type: AgentType.SurveyAgent,\n    description: {\n      pl: \"Agenci ankietowi su do zbierania informacji lub opinii od uytkownikw. Na podstawie poprzednich odpowiedzi mog **dynamicznie dostosowywa** kolejne pytania. Ci agenci zapisuj odpowiedzi do dalszego przetwarzania w podanym formacie. Mog zastpi narzdzia takie jak **Formularze, Ankiety, Formularze zgoszeniowe** itp.\",\n      en: \"Survey agents are used to collect information or opinions from users. Based on previous answers, they can **dynamically adjust** the next questions. These agents save the answers for further processing in the desired format. They can replace tools like **Forms, Polls, Intake forms** etc.\"    \n    },\n    supportsUserFacingUI: true,\n    requiredTabs: ['prompt', 'expectedResult'],\n    displayName: {\n      'pl': 'Agent przeprowadzajcy ankiety [Chat]',\n      'en': 'Survey agent [Chat]'\n    }\n  },\n  {\n    type: AgentType.CommerceAgent,\n    description: {\n      pl: \"Agenci handlowi su do **sprzeday produktw lub usug**. Mog by uywane w **e-commerce**, **rezerwacji usug**, **b2b/cpq**. Operuj na **katalogu produktw** i mog by uywane do **sprzeday dodatkowej** lub **sprzeday krzyowej** produktw.\",\n      en: \"Commerce agents are used to **sell products or services**. They can be used in **e-commerce**, **service booking**, **b2b/cpq** scenarios. They operate on the **product catalog** and can be used to **upsell** or **cross-sell** products.\"            \n    },\n    supportsUserFacingUI: true,\n    requiredTabs: ['prompt', 'expectedResult'],\n    displayName: {\n      'pl': 'Asystent sprzeday [Chat]',\n      'en': 'Sales assistant [Chat]'\n    }\n  },\n  {\n    type: AgentType.Flow,\n    description: {\n      pl: \"Agenci oparte na przepywach pozwalaj na tworzenie **zoonych scenariuszy**. Mog by uywane do **automatyzacji procesw** i rozwijania aplikacji, ktre s wywoywane przez API lub inne agenty, za pomoc **jzyka naturalnego**. Mog by uywane do **tworzenia drzew decyzyjnych** lub **integracji**.\",\n      en: \"Flow-based agents let you create **complex scenarios**. They can be used to **automate processes** and develop apps that are called by API or other agents, using **natural language**. They can be used to **create decision trees** or **integrations**.\"    \n    },\n    supportsUserFacingUI: true,\n    requiredTabs: [],\n    displayName: {\n      'pl': 'Aplikacja / Workflow [API]',\n      'en': 'App / Workflow [API]'\n    }\n  }\n];\n\n/**\n * Get agent type descriptor by type\n */\nexport function getAgentTypeDescriptor(type: AgentType): AgentTypeDescriptor | undefined {\n  return agentTypesRegistry.find(descriptor => descriptor.type === type);\n}\n\n/**\n * Get all agent type descriptors\n */\nexport function getAllAgentTypeDescriptors(): AgentTypeDescriptor[] {\n  return [...agentTypesRegistry];\n}\n\n/**\n * Check if agent type is valid\n */\nexport function isValidAgentType(type: string): type is AgentType {\n  return agentTypesRegistry.some(descriptor => descriptor.type === type);\n}\n","import { AgentConfig, AgentType } from '../types';\n\n/**\n * Validate agent configuration\n */\nexport function validateAgentConfig(config: Partial<AgentConfig>): { valid: boolean; errors: string[] } {\n  const errors: string[] = [];\n\n  if (!config.name || config.name.trim() === '') {\n    errors.push('Agent name is required');\n  }\n\n  if (!config.agentType) {\n    errors.push('Agent type is required');\n  }\n\n  if (config.agentType && !Object.values(AgentType).includes(config.agentType)) {\n    errors.push(`Invalid agent type: ${config.agentType}`);\n  }\n\n  return {\n    valid: errors.length === 0,\n    errors\n  };\n}\n\n/**\n * Validate agent tools configuration\n */\nexport function validateAgentTools(tools: Record<string, any>): { valid: boolean; errors: string[] } {\n  const errors: string[] = [];\n\n  for (const [key, config] of Object.entries(tools)) {\n    if (!config.tool) {\n      errors.push(`Tool configuration for '${key}' is missing 'tool' property`);\n    }\n  }\n\n  return {\n    valid: errors.length === 0,\n    errors\n  };\n}\n","import { AgentConfig, AgentType, ToolConfiguration, AgentFlow } from '../types';\nimport { validateAgentConfig, validateAgentTools } from '../agent-types';\nimport { nanoid } from 'nanoid';\n\n/**\n * Fluent API for building agents\n */\nexport class AgentBuilder {\n  private config: Partial<AgentConfig> = {};\n\n  /**\n   * Set agent type\n   */\n  public setType(type: AgentType): this {\n    this.config.agentType = type;\n    return this;\n  }\n\n  /**\n   * Set agent name\n   */\n  public setName(name: string): this {\n    this.config.name = name;\n    return this;\n  }\n\n  /**\n   * Set agent ID\n   */\n  public setId(id: string): this {\n    this.config.id = id;\n    return this;\n  }\n\n  /**\n   * Set system prompt\n   */\n  public setPrompt(prompt: string): this {\n    this.config.prompt = prompt;\n    return this;\n  }\n\n  /**\n   * Add a tool\n   */\n  public addTool(key: string, config: ToolConfiguration): this {\n    if (!this.config.tools) {\n      this.config.tools = {};\n    }\n    this.config.tools[key] = config;\n    return this;\n  }\n\n  /**\n   * Remove a tool\n   */\n  public removeTool(key: string): this {\n    if (this.config.tools) {\n      delete this.config.tools[key];\n    }\n    return this;\n  }\n\n  /**\n   * Set all tools\n   */\n  public setTools(tools: Record<string, ToolConfiguration>): this {\n    this.config.tools = tools;\n    return this;\n  }\n\n  /**\n   * Add a flow\n   */\n  public addFlow(flow: AgentFlow): this {\n    if (!this.config.flows) {\n      this.config.flows = [];\n    }\n    this.config.flows.push(flow);\n    return this;\n  }\n\n  /**\n   * Set all flows\n   */\n  public setFlows(flows: AgentFlow[]): this {\n    this.config.flows = flows;\n    return this;\n  }\n\n  /**\n   * Set expected result schema\n   */\n  public setExpectedResult(schema: any): this {\n    this.config.expectedResult = schema;\n    return this;\n  }\n\n  /**\n   * Set locale\n   */\n  public setLocale(locale: string): this {\n    this.config.locale = locale;\n    return this;\n  }\n\n  /**\n   * Set events\n   */\n  public setEvents(events: any[]): this {\n    this.config.events = events;\n    return this;\n  }\n\n  /**\n   * Set settings\n   */\n  public setSettings(settings: Record<string, any>): this {\n    this.config.settings = settings;\n    return this;\n  }\n\n  /**\n   * Set metadata\n   */\n  public setMetadata(metadata: Record<string, any>): this {\n    this.config.metadata = metadata;\n    return this;\n  }\n\n  /**\n   * Build the agent configuration\n   */\n  public build(): AgentConfig {\n    this.validate();\n    \n    return {\n      id: this.config.id || nanoid(),\n      name: this.config.name!,\n      agentType: this.config.agentType!,\n      locale: this.config.locale || 'en',\n      prompt: this.config.prompt,\n      expectedResult: this.config.expectedResult,\n      tools: this.config.tools || {},\n      flows: this.config.flows || [],\n      events: this.config.events || [],\n      settings: this.config.settings || {},\n      metadata: this.config.metadata || {},\n    };\n  }\n\n  /**\n   * Validate configuration before building\n   */\n  private validate(): void {\n    const validation = validateAgentConfig(this.config);\n    if (!validation.valid) {\n      throw new Error(`Agent configuration validation failed: ${validation.errors.join(', ')}`);\n    }\n\n    if (this.config.tools) {\n      const toolsValidation = validateAgentTools(this.config.tools);\n      if (!toolsValidation.valid) {\n        throw new Error(`Agent tools validation failed: ${toolsValidation.errors.join(', ')}`);\n      }\n    }\n  }\n\n  /**\n   * Load from existing config\n   */\n  public static from(config: AgentConfig): AgentBuilder {\n    const builder = new AgentBuilder();\n    builder.config = { ...config };\n    return builder;\n  }\n\n  /**\n   * Create a new builder instance\n   */\n  public static create(): AgentBuilder {\n    return new AgentBuilder();\n  }\n}\n","import { ToolDescriptor } from '../types';\n\n/**\n * Tool Registry\n * Manages registration and retrieval of tools\n */\nexport class ToolRegistry {\n  private tools: Map<string, ToolDescriptor> = new Map();\n\n  /**\n   * Register a tool\n   */\n  public register(name: string, descriptor: ToolDescriptor): void {\n    if (this.tools.has(name)) {\n      console.warn(`Tool '${name}' is already registered. Overwriting.`);\n    }\n    this.tools.set(name, descriptor);\n  }\n\n  /**\n   * Register multiple tools at once\n   */\n  public registerMany(tools: Record<string, ToolDescriptor>): void {\n    Object.entries(tools).forEach(([name, descriptor]) => {\n      this.register(name, descriptor);\n    });\n  }\n\n  /**\n   * Get a tool by name\n   */\n  public get(name: string): ToolDescriptor | undefined {\n    return this.tools.get(name);\n  }\n\n  /**\n   * Check if a tool exists\n   */\n  public has(name: string): boolean {\n    return this.tools.has(name);\n  }\n\n  /**\n   * Get all tool names\n   */\n  public list(): string[] {\n    return Array.from(this.tools.keys());\n  }\n\n  /**\n   * Get all tools\n   */\n  public getAll(): Record<string, ToolDescriptor> {\n    const result: Record<string, ToolDescriptor> = {};\n    this.tools.forEach((descriptor, name) => {\n      result[name] = descriptor;\n    });\n    return result;\n  }\n\n  /**\n   * Remove a tool\n   */\n  public unregister(name: string): boolean {\n    return this.tools.delete(name);\n  }\n\n  /**\n   * Clear all tools\n   */\n  public clear(): void {\n    this.tools.clear();\n  }\n\n  /**\n   * Get the number of registered tools\n   */\n  public size(): number {\n    return this.tools.size;\n  }\n}\n\n/**\n * Global tool registry instance\n */\nexport const globalToolRegistry = new ToolRegistry();\n","import { z } from 'zod';\nimport { tool } from 'ai';\nimport { ToolDescriptor } from '../../types';\n\n/**\n * Current Date Tool\n * Returns the current date in ISO format\n */\nexport const currentDateTool: ToolDescriptor = {\n  displayName: 'Get current date',\n  tool: tool({\n    description: 'Get the current date and time in ISO format (UTC timezone)',\n    parameters: z.object({}),\n    execute: async () => {\n      return new Date().toISOString();\n    },\n  }),\n};\n","import { z } from 'zod';\nimport { tool } from 'ai';\nimport { ToolDescriptor } from '../../types';\n\n/**\n * Day Name Tool\n * Returns the name of the day for a given date\n */\nexport const dayNameTool: ToolDescriptor = {\n  displayName: 'Get day name',\n  tool: tool({\n    description: 'Get the name of the day (e.g., Monday, Tuesday) for a given date',\n    parameters: z.object({\n      date: z.string().describe('The date to get the day name for in ISO format (e.g., 2024-01-15)'),\n      locale: z.string().optional().describe('The locale to use for the day name (e.g., en-US, pl-PL). Defaults to en-US'),\n    }),\n    execute: async ({ date, locale = 'en-US' }) => {\n      return new Date(date).toLocaleDateString(locale, { weekday: 'long' });\n    },\n  }),\n};\n","import { z } from 'zod';\nimport { tool } from 'ai';\nimport { ToolDescriptor } from '../../types';\n\n/**\n * HTTP Tool Configuration Options\n */\nexport interface HttpToolOptions {\n  /**\n   * Maximum timeout for HTTP requests in milliseconds\n   * @default 30000 (30 seconds)\n   */\n  timeout?: number;\n\n  /**\n   * Maximum number of redirects to follow\n   * @default 5\n   */\n  maxRedirects?: number;\n\n  /**\n   * Whether to validate SSL certificates\n   * @default true\n   */\n  validateSSL?: boolean;\n}\n\n/**\n * Makes HTTP requests to external APIs\n */\nasync function makeHttpRequest({\n  url,\n  method,\n  headers,\n  body,\n  options = {},\n}: {\n  url: string;\n  method: 'GET' | 'POST' | 'PUT' | 'DELETE' | 'PATCH';\n  headers?: Record<string, string>;\n  body?: string;\n  options?: HttpToolOptions;\n}): Promise<string> {\n  try {\n    const fetchOptions: RequestInit = {\n      method,\n      headers: {\n        'Content-Type': 'application/json',\n        ...headers,\n      },\n      body: body && method !== 'GET' ? body : undefined,\n    };\n\n    const response = await fetch(url, fetchOptions);\n\n    if (!response.ok) {\n      throw new Error(`HTTP ${response.status}: ${response.statusText}`);\n    }\n\n    const contentType = response.headers.get('content-type');\n    if (contentType?.includes('application/json')) {\n      const data = await response.json();\n      return JSON.stringify(data);\n    } else {\n      return await response.text();\n    }\n  } catch (error) {\n    if (error instanceof Error) {\n      throw new Error(`HTTP request failed: ${error.message}`);\n    }\n    throw new Error('HTTP request failed with unknown error');\n  }\n}\n\n/**\n * Create HTTP Tool\n * Factory function to create an HTTP tool with custom options\n */\nexport function createHttpTool(options: HttpToolOptions = {}): ToolDescriptor {\n  return {\n    displayName: 'Make HTTP request',\n    tool: tool({\n      description: 'Makes HTTP requests to specified URLs with configurable method, headers, and body. Supports GET, POST, PUT, DELETE, and PATCH methods.',\n      parameters: z.object({\n        url: z.string().describe('The URL to make the request to (must be a valid HTTP/HTTPS URL)'),\n        method: z.enum(['GET', 'POST', 'PUT', 'DELETE', 'PATCH']).describe('The HTTP method to use'),\n        headers: z.record(z.string()).optional().describe('Optional headers to include in the request as key-value pairs'),\n        body: z.string().optional().describe('The body of the request. For POST/PUT/PATCH, this should be a JSON string. Not used for GET/DELETE.'),\n      }),\n      execute: async ({ url, method, headers, body }) => {\n        return makeHttpRequest({ url, method, headers, body, options });\n      },\n    }),\n  };\n}\n\n/**\n * Default HTTP Tool instance\n */\nexport const httpTool: ToolDescriptor = createHttpTool();\n","import { z } from 'zod';\nimport { tool } from 'ai';\nimport { ToolDescriptor } from '../../types';\n\n/**\n * Email Tool Configuration Options\n */\nexport interface EmailToolOptions {\n  /**\n   * Email service provider API key\n   * Required for sending emails\n   */\n  apiKey: string;\n\n  /**\n   * Email service provider API URL\n   * @default 'https://api.resend.com/emails'\n   */\n  apiUrl?: string;\n\n  /**\n   * Default \"from\" email address\n   * Can be overridden per email\n   */\n  defaultFrom?: string;\n}\n\n/**\n * Send email using Resend API\n */\nasync function sendEmail({\n  from,\n  to,\n  subject,\n  text,\n  html,\n  apiKey,\n  apiUrl = 'https://api.resend.com/emails',\n}: {\n  from: string;\n  to: string[];\n  subject: string;\n  text: string;\n  html: string;\n  apiKey: string;\n  apiUrl?: string;\n}): Promise<string> {\n  try {\n    const response = await fetch(apiUrl, {\n      method: 'POST',\n      headers: {\n        'Authorization': `Bearer ${apiKey}`,\n        'Content-Type': 'application/json',\n      },\n      body: JSON.stringify({\n        from,\n        to,\n        subject,\n        text,\n        html,\n      }),\n    });\n\n    if (!response.ok) {\n      const errorData = await response.text();\n      throw new Error(`Email sending failed (${response.status}): ${errorData}`);\n    }\n\n    const data = await response.json();\n    return JSON.stringify(data);\n  } catch (error) {\n    if (error instanceof Error) {\n      throw new Error(`Failed to send email: ${error.message}`);\n    }\n    throw new Error('Failed to send email with unknown error');\n  }\n}\n\n/**\n * Create Email Tool\n * Factory function to create an email tool with custom configuration\n */\nexport function createEmailTool(options: EmailToolOptions): ToolDescriptor {\n  const { apiKey, apiUrl, defaultFrom } = options;\n\n  if (!apiKey) {\n    throw new Error('Email tool requires an apiKey in options');\n  }\n\n  return {\n    displayName: 'Send email',\n    tool: tool({\n      description: 'Sends an email using the Resend.com API. Provide sender, recipients, subject, and content.',\n      parameters: z.object({\n        from: z.string().describe('The sender email address (e.g., \"Sender Name <sender@example.com>\"). Can use default if configured.').optional(),\n        to: z.array(z.string()).describe('Array of recipient email addresses (e.g., [\"user@example.com\"])'),\n        subject: z.string().describe('The subject line of the email'),\n        text: z.string().describe('Plain text content of the email'),\n        html: z.string().describe('HTML content of the email'),\n      }),\n      execute: async ({ from, to, subject, text, html }) => {\n        const senderEmail = from || defaultFrom;\n        \n        if (!senderEmail) {\n          throw new Error('Email \"from\" address is required. Provide it in the parameters or set defaultFrom in options.');\n        }\n\n        return sendEmail({\n          from: senderEmail,\n          to,\n          subject,\n          text,\n          html,\n          apiKey,\n          apiUrl,\n        });\n      },\n    }),\n  };\n}\n","import { nanoid } from 'nanoid';\nimport { EditorStep, AgentFlow, FlowInputVariable } from '../types';\n\n/**\n * FlowBuilder\n * Fluent API for building flow definitions\n */\nexport class FlowBuilder {\n  private flow: Partial<AgentFlow> = {};\n\n  /**\n   * Set flow ID\n   */\n  public setId(id: string): this {\n    this.flow.id = id;\n    return this;\n  }\n\n  /**\n   * Set flow code (unique identifier)\n   */\n  public setCode(code: string): this {\n    this.flow.code = code;\n    return this;\n  }\n\n  /**\n   * Set flow name\n   */\n  public setName(name: string): this {\n    this.flow.name = name;\n    return this;\n  }\n\n  /**\n   * Set flow description\n   */\n  public setDescription(description: string): this {\n    this.flow.description = description;\n    return this;\n  }\n\n  /**\n   * Add an input variable\n   */\n  public addInput(input: FlowInputVariable): this {\n    if (!this.flow.inputs) {\n      this.flow.inputs = [];\n    }\n    this.flow.inputs.push(input);\n    return this;\n  }\n\n  /**\n   * Set all input variables\n   */\n  public setInputs(inputs: FlowInputVariable[]): this {\n    this.flow.inputs = inputs;\n    return this;\n  }\n\n  /**\n   * Set the flow definition\n   */\n  public setFlow(flow: EditorStep): this {\n    this.flow.flow = flow;\n    return this;\n  }\n\n  /**\n   * Add an agent definition\n   */\n  public addAgent(agent: any): this {\n    if (!this.flow.agents) {\n      this.flow.agents = [];\n    }\n    this.flow.agents.push(agent);\n    return this;\n  }\n\n  /**\n   * Set all agents\n   */\n  public setAgents(agents: any[]): this {\n    this.flow.agents = agents;\n    return this;\n  }\n\n  /**\n   * Build the flow\n   */\n  public build(): AgentFlow {\n    this.validate();\n\n    return {\n      id: this.flow.id || nanoid(),\n      code: this.flow.code!,\n      name: this.flow.name!,\n      description: this.flow.description,\n      inputs: this.flow.inputs || [],\n      flow: this.flow.flow,\n      agents: this.flow.agents || [],\n    };\n  }\n\n  /**\n   * Validate the flow configuration\n   */\n  private validate(): void {\n    if (!this.flow.code) {\n      throw new Error('Flow code is required');\n    }\n    if (!this.flow.name) {\n      throw new Error('Flow name is required');\n    }\n\n    // Validate input variables\n    if (this.flow.inputs) {\n      const names = new Set<string>();\n      for (const input of this.flow.inputs) {\n        if (!input.name) {\n          throw new Error('Input variable name is required');\n        }\n        if (names.has(input.name)) {\n          throw new Error(`Duplicate input variable name: ${input.name}`);\n        }\n        names.add(input.name);\n      }\n    }\n  }\n\n  /**\n   * Create a builder from existing flow\n   */\n  public static from(flow: AgentFlow): FlowBuilder {\n    const builder = new FlowBuilder();\n    builder.flow = { ...flow };\n    return builder;\n  }\n\n  /**\n   * Create a new builder instance\n   */\n  public static create(): FlowBuilder {\n    return new FlowBuilder();\n  }\n}\n","/**\n * Flow Executor\n * Executes flow-based agents with full LLM and tool integration\n */\n\nimport { LLMProvider, Message } from '../providers';\nimport { ToolRegistry } from '../tools';\nimport { AgentFlow, EditorStep } from '../types';\nimport { AgentConfig } from '../types';\n\n/**\n * Flow execution context\n */\nexport interface FlowExecutionContext {\n  agent: AgentConfig;\n  session?: any;\n  variables: Record<string, any>;\n  provider: LLMProvider;\n  toolRegistry?: ToolRegistry;\n  memory?: any[];\n  maxDepth?: number;\n  currentDepth?: number;\n}\n\n/**\n * Flow execution event types\n */\nexport type FlowExecutionEventType =\n  | 'flow-start'\n  | 'flow-complete'\n  | 'flow-error'\n  | 'step-start'\n  | 'step-complete'\n  | 'step-error'\n  | 'variable-set'\n  | 'llm-call'\n  | 'llm-response'\n  | 'tool-call'\n  | 'tool-result'\n  | 'condition-evaluated'\n  | 'loop-iteration';\n\n/**\n * Flow execution event\n */\nexport interface FlowExecutionEvent {\n  type: FlowExecutionEventType;\n  timestamp: Date;\n  stepId?: string;\n  stepType?: string;\n  data?: any;\n  variables?: Record<string, any>;\n  error?: Error;\n}\n\n/**\n * Flow execution result\n */\nexport interface FlowExecutionResult {\n  success: boolean;\n  output: any;\n  variables: Record<string, any>;\n  steps: number;\n  events: FlowExecutionEvent[];\n  error?: Error;\n}\n\n/**\n * Flow Executor\n */\nexport class FlowExecutor {\n  /**\n   * Execute a flow\n   */\n  static async execute(\n    flow: AgentFlow,\n    context: FlowExecutionContext,\n    onEvent?: (event: FlowExecutionEvent) => void\n  ): Promise<FlowExecutionResult> {\n    const events: FlowExecutionEvent[] = [];\n    const variables = { ...context.variables };\n    let steps = 0;\n\n    // Emit flow start event\n    const startEvent: FlowExecutionEvent = {\n      type: 'flow-start',\n      timestamp: new Date(),\n      data: { flowCode: flow.code, flowName: flow.name },\n    };\n    events.push(startEvent);\n    onEvent?.(startEvent);\n\n    try {\n      // Execute the flow\n      const output = await this.executeNode(\n        flow.flow,\n        { ...context, variables, currentDepth: 0 },\n        events,\n        onEvent\n      );\n      steps = events.filter(e => e.type === 'step-complete').length;\n\n      // Emit flow complete event\n      const completeEvent: FlowExecutionEvent = {\n        type: 'flow-complete',\n        timestamp: new Date(),\n        data: { output, steps },\n        variables,\n      };\n      events.push(completeEvent);\n      onEvent?.(completeEvent);\n\n      return {\n        success: true,\n        output,\n        variables,\n        steps,\n        events,\n      };\n    } catch (error) {\n      // Emit flow error event\n      const errorEvent: FlowExecutionEvent = {\n        type: 'flow-error',\n        timestamp: new Date(),\n        error: error as Error,\n      };\n      events.push(errorEvent);\n      onEvent?.(errorEvent);\n\n      return {\n        success: false,\n        output: null,\n        variables,\n        steps: events.filter(e => e.type === 'step-complete').length,\n        events,\n        error: error as Error,\n      };\n    }\n  }\n\n  /**\n   * Execute a single flow node\n   */\n  private static async executeNode(\n    node: EditorStep | any,\n    context: FlowExecutionContext,\n    events: FlowExecutionEvent[],\n    onEvent?: (event: FlowExecutionEvent) => void\n  ): Promise<any> {\n    // Check depth to prevent infinite recursion\n    const maxDepth = context.maxDepth || 100;\n    const currentDepth = context.currentDepth || 0;\n    if (currentDepth > maxDepth) {\n      throw new Error(`Maximum flow depth ${maxDepth} exceeded`);\n    }\n\n    const stepId = (node as any).id || `step-${Date.now()}`;\n\n    // Emit step start event\n    const startEvent: FlowExecutionEvent = {\n      type: 'step-start',\n      timestamp: new Date(),\n      stepId,\n      stepType: node.type,\n    };\n    events.push(startEvent);\n    onEvent?.(startEvent);\n\n    try {\n      let result: any;\n\n      switch (node.type) {\n        case 'sequence':\n          result = await this.executeSequence(node, context, events, onEvent);\n          break;\n        case 'parallel':\n          result = await this.executeParallel(node, context, events, onEvent);\n          break;\n        case 'oneOf':\n          result = await this.executeOneOf(node, context, events, onEvent);\n          break;\n        case 'forEach':\n          result = await this.executeForEach(node, context, events, onEvent);\n          break;\n        case 'evaluator':\n          result = await this.executeEvaluator(node, context, events, onEvent);\n          break;\n        case 'llmCall':\n          result = await this.executeLLMCall(node, context, events, onEvent);\n          break;\n        case 'toolCall':\n          result = await this.executeToolCall(node, context, events, onEvent);\n          break;\n        case 'setVariable':\n          result = await this.executeSetVariable(node, context, events, onEvent);\n          break;\n        case 'return':\n          result = this.executeReturn(node, context);\n          break;\n        case 'end':\n          result = this.executeEnd(node, context);\n          break;\n        case 'throw':\n          throw new Error(this.interpolate((node as any).message || 'Flow error', context.variables));\n        default:\n          throw new Error(`Unknown node type: ${(node as any).type}`);\n      }\n\n      // Emit step complete event\n      const completeEvent: FlowExecutionEvent = {\n        type: 'step-complete',\n        timestamp: new Date(),\n        stepId,\n        stepType: node.type,\n        data: result,\n      };\n      events.push(completeEvent);\n      onEvent?.(completeEvent);\n\n      return result;\n    } catch (error) {\n      // Emit step error event\n      const errorEvent: FlowExecutionEvent = {\n        type: 'step-error',\n        timestamp: new Date(),\n        stepId,\n        stepType: node.type,\n        error: error as Error,\n      };\n      events.push(errorEvent);\n      onEvent?.(errorEvent);\n\n      throw error;\n    }\n  }\n\n  /**\n   * Execute sequence node\n   */\n  private static async executeSequence(\n    node: any,\n    context: FlowExecutionContext,\n    events: FlowExecutionEvent[],\n    onEvent?: (event: FlowExecutionEvent) => void\n  ): Promise<any> {\n    const steps = node.steps || [];\n    let lastResult: any = null;\n\n    for (const step of steps) {\n      lastResult = await this.executeNode(\n        step,\n        { ...context, currentDepth: (context.currentDepth || 0) + 1 },\n        events,\n        onEvent\n      );\n    }\n\n    return lastResult;\n  }\n\n  /**\n   * Execute parallel node\n   */\n  private static async executeParallel(\n    node: any,\n    context: FlowExecutionContext,\n    events: FlowExecutionEvent[],\n    onEvent?: (event: FlowExecutionEvent) => void\n  ): Promise<any[]> {\n    const steps = node.steps || [];\n    \n    const results = await Promise.all(\n      steps.map((step: any) =>\n        this.executeNode(\n          step,\n          { ...context, currentDepth: (context.currentDepth || 0) + 1 },\n          events,\n          onEvent\n        )\n      )\n    );\n\n    return results;\n  }\n\n  /**\n   * Execute oneOf (conditional) node\n   */\n  private static async executeOneOf(\n    node: any,\n    context: FlowExecutionContext,\n    events: FlowExecutionEvent[],\n    onEvent?: (event: FlowExecutionEvent) => void\n  ): Promise<any> {\n    const options = node.options || [];\n\n    for (const option of options) {\n      // Evaluate condition if present\n      if (option.condition) {\n        const conditionMet = this.evaluateCondition(option.condition, context.variables);\n        \n        // Emit condition evaluated event\n        const conditionEvent: FlowExecutionEvent = {\n          type: 'condition-evaluated',\n          timestamp: new Date(),\n          data: { condition: option.condition, result: conditionMet },\n        };\n        events.push(conditionEvent);\n        onEvent?.(conditionEvent);\n\n        if (conditionMet) {\n          return await this.executeNode(\n            option.step,\n            { ...context, currentDepth: (context.currentDepth || 0) + 1 },\n            events,\n            onEvent\n          );\n        }\n      } else {\n        // Default option (no condition)\n        return await this.executeNode(\n          option.step,\n          { ...context, currentDepth: (context.currentDepth || 0) + 1 },\n          events,\n          onEvent\n        );\n      }\n    }\n\n    return null;\n  }\n\n  /**\n   * Execute forEach loop node\n   */\n  private static async executeForEach(\n    node: any,\n    context: FlowExecutionContext,\n    events: FlowExecutionEvent[],\n    onEvent?: (event: FlowExecutionEvent) => void\n  ): Promise<any[]> {\n    const items = this.resolveValue(node.items, context.variables) || [];\n    const itemVar = node.itemVariable || 'item';\n    const indexVar = node.indexVariable || 'index';\n    const results: any[] = [];\n\n    for (let i = 0; i < items.length; i++) {\n      // Set loop variables in the current context\n      context.variables[itemVar] = items[i];\n      context.variables[indexVar] = i;\n\n      // Emit loop iteration event\n      const iterationEvent: FlowExecutionEvent = {\n        type: 'loop-iteration',\n        timestamp: new Date(),\n        data: { item: items[i], index: i },\n      };\n      events.push(iterationEvent);\n      onEvent?.(iterationEvent);\n\n      // Execute step with updated context\n      if (node.step) {\n        const result = await this.executeNode(\n          node.step,\n          { ...context, currentDepth: (context.currentDepth || 0) + 1 },\n          events,\n          onEvent\n        );\n        results.push(result);\n      }\n    }\n\n    return results;\n  }\n\n  /**\n   * Execute evaluator node\n   */\n  private static async executeEvaluator(\n    node: any,\n    context: FlowExecutionContext,\n    events: FlowExecutionEvent[],\n    onEvent?: (event: FlowExecutionEvent) => void\n  ): Promise<any> {\n    const expression = node.expression || '';\n    return this.evaluateExpression(expression, context.variables);\n  }\n\n  /**\n   * Execute LLM call node\n   */\n  private static async executeLLMCall(\n    node: any,\n    context: FlowExecutionContext,\n    events: FlowExecutionEvent[],\n    onEvent?: (event: FlowExecutionEvent) => void\n  ): Promise<string> {\n    const prompt = this.interpolate(node.prompt || '', context.variables);\n    const model = node.model || context.agent.settings?.model || 'gpt-4';\n\n    // Build messages\n    const messages: Message[] = [];\n    \n    // Add system prompt if available\n    if (context.agent.prompt) {\n      messages.push({\n        role: 'system',\n        content: context.agent.prompt,\n      });\n    }\n\n    // Add user message\n    messages.push({\n      role: 'user',\n      content: prompt,\n    });\n\n    // Emit LLM call event\n    const callEvent: FlowExecutionEvent = {\n      type: 'llm-call',\n      timestamp: new Date(),\n      data: { model, prompt },\n    };\n    events.push(callEvent);\n    onEvent?.(callEvent);\n\n    // Call LLM\n    const result = await context.provider.generate({\n      model,\n      messages,\n      temperature: node.temperature,\n      maxTokens: node.maxTokens,\n    });\n\n    // Emit LLM response event\n    const responseEvent: FlowExecutionEvent = {\n      type: 'llm-response',\n      timestamp: new Date(),\n      data: { text: result.text, usage: result.usage },\n    };\n    events.push(responseEvent);\n    onEvent?.(responseEvent);\n\n    // Store result in variable if specified\n    if (node.outputVariable) {\n      context.variables[node.outputVariable] = result.text;\n      \n      const varEvent: FlowExecutionEvent = {\n        type: 'variable-set',\n        timestamp: new Date(),\n        data: { variable: node.outputVariable, value: result.text },\n      };\n      events.push(varEvent);\n      onEvent?.(varEvent);\n    }\n\n    return result.text;\n  }\n\n  /**\n   * Execute tool call node\n   */\n  private static async executeToolCall(\n    node: any,\n    context: FlowExecutionContext,\n    events: FlowExecutionEvent[],\n    onEvent?: (event: FlowExecutionEvent) => void\n  ): Promise<any> {\n    if (!context.toolRegistry) {\n      throw new Error('Tool registry not available');\n    }\n\n    const toolName = node.tool || '';\n    const toolDesc = context.toolRegistry.get(toolName);\n    \n    if (!toolDesc || !toolDesc.tool) {\n      throw new Error(`Tool '${toolName}' not found`);\n    }\n\n    // Interpolate arguments\n    const args = this.interpolateObject(node.arguments || {}, context.variables);\n\n    // Emit tool call event\n    const callEvent: FlowExecutionEvent = {\n      type: 'tool-call',\n      timestamp: new Date(),\n      data: { tool: toolName, arguments: args },\n    };\n    events.push(callEvent);\n    onEvent?.(callEvent);\n\n    // Execute tool\n    const result = toolDesc.tool.execute ? await toolDesc.tool.execute(args, {} as any) : null;\n\n    // Emit tool result event\n    const resultEvent: FlowExecutionEvent = {\n      type: 'tool-result',\n      timestamp: new Date(),\n      data: { tool: toolName, result },\n    };\n    events.push(resultEvent);\n    onEvent?.(resultEvent);\n\n    // Store result in variable if specified\n    if (node.outputVariable) {\n      context.variables[node.outputVariable] = result;\n      \n      const varEvent: FlowExecutionEvent = {\n        type: 'variable-set',\n        timestamp: new Date(),\n        data: { variable: node.outputVariable, value: result },\n      };\n      events.push(varEvent);\n      onEvent?.(varEvent);\n    }\n\n    return result;\n  }\n\n  /**\n   * Execute setVariable node\n   */\n  private static async executeSetVariable(\n    node: any,\n    context: FlowExecutionContext,\n    events: FlowExecutionEvent[],\n    onEvent?: (event: FlowExecutionEvent) => void\n  ): Promise<any> {\n    const variableName = node.variable || '';\n    const value = this.resolveValue(node.value, context.variables);\n\n    context.variables[variableName] = value;\n\n    const varEvent: FlowExecutionEvent = {\n      type: 'variable-set',\n      timestamp: new Date(),\n      data: { variable: variableName, value },\n    };\n    events.push(varEvent);\n    onEvent?.(varEvent);\n\n    return value;\n  }\n\n  /**\n   * Execute return node\n   */\n  private static executeReturn(\n    node: any,\n    context: FlowExecutionContext\n  ): any {\n    return this.resolveValue(node.value, context.variables);\n  }\n\n  /**\n   * Execute end node\n   */\n  private static executeEnd(\n    node: any,\n    context: FlowExecutionContext\n  ): any {\n    return this.resolveValue(node.value, context.variables);\n  }\n\n  /**\n   * Interpolate string with variables\n   */\n  private static interpolate(template: string, variables: Record<string, any>): string {\n    return template.replace(/\\{\\{(\\w+)\\}\\}/g, (_, key) => {\n      return variables[key]?.toString() || '';\n    });\n  }\n\n  /**\n   * Interpolate object with variables\n   */\n  private static interpolateObject(obj: any, variables: Record<string, any>): any {\n    if (typeof obj === 'string') {\n      return this.interpolate(obj, variables);\n    }\n    if (Array.isArray(obj)) {\n      return obj.map(item => this.interpolateObject(item, variables));\n    }\n    if (obj && typeof obj === 'object') {\n      const result: any = {};\n      for (const [key, value] of Object.entries(obj)) {\n        result[key] = this.interpolateObject(value, variables);\n      }\n      return result;\n    }\n    return obj;\n  }\n\n  /**\n   * Resolve a value (can be literal or variable reference)\n   */\n  private static resolveValue(value: any, variables: Record<string, any>): any {\n    if (typeof value === 'string' && value.startsWith('$')) {\n      const varName = value.substring(1);\n      return variables[varName];\n    }\n    return value;\n  }\n\n  /**\n   * Evaluate a condition\n   */\n  private static evaluateCondition(condition: string, variables: Record<string, any>): boolean {\n    try {\n      // Simple evaluation - supports basic comparisons\n      // In production, use a safe expression evaluator\n      const interpolated = this.interpolate(condition, variables);\n      return !!eval(interpolated);\n    } catch {\n      return false;\n    }\n  }\n\n  /**\n   * Evaluate an expression\n   */\n  private static evaluateExpression(expression: string, variables: Record<string, any>): any {\n    try {\n      const interpolated = this.interpolate(expression, variables);\n      return eval(interpolated);\n    } catch (error) {\n      throw new Error(`Failed to evaluate expression: ${expression}`);\n    }\n  }\n}\n","import { nanoid } from 'nanoid';\nimport { EditorStep } from '../types';\n\n/**\n * Convert EditorStep to flows-ai compatible FlowDefinition\n * This recursively transforms the internal EditorStep structure\n * to the format expected by the flows-ai execution engine\n */\nexport function convertToFlowDefinition(step: EditorStep): any {\n  switch (step.type) {\n    // ------------------------------------\n    // STEP - Basic agent execution\n    // ------------------------------------\n    case 'step':\n      return {\n        id: nanoid(),\n        agent: step.agent,\n        input: step.input,\n      };\n\n    // ------------------------------------\n    // SEQUENCE - Execute steps in order\n    // ------------------------------------\n    case 'sequence':\n      return {\n        id: nanoid(),\n        agent: 'sequenceAgent',\n        input: step.steps.map((child) => convertToFlowDefinition(child)),\n      };\n\n    // ------------------------------------\n    // PARALLEL - Execute steps concurrently\n    // ------------------------------------\n    case 'parallel':\n      return {\n        id: nanoid(),\n        agent: 'parallelAgent',\n        input: step.steps.map((child) => convertToFlowDefinition(child)),\n      };\n\n    // ------------------------------------\n    // ONE-OF - Conditional branching\n    // ------------------------------------\n    case 'oneOf':\n      const flows = step.branches.map((b) => convertToFlowDefinition(b.flow));\n      const conditions = step.branches.map((b) => b.when);\n      return {\n        id: nanoid(),\n        agent: 'oneOfAgent',\n        input: flows,\n        conditions: conditions,\n      };\n\n    // ------------------------------------\n    // FOR-EACH - Iterate over items\n    // ------------------------------------\n    case 'forEach':\n      return {\n        id: nanoid(),\n        agent: 'forEachAgent',\n        item: step.item,\n        input: convertToFlowDefinition(step.inputFlow),\n      };\n\n    // ------------------------------------\n    // EVALUATOR - Self-improvement loop\n    // ------------------------------------\n    case 'evaluator':\n      return {\n        id: nanoid(),\n        agent: 'optimizeAgent',\n        criteria: step.criteria,\n        max_iterations: step.max_iterations,\n        input: convertToFlowDefinition(step.subFlow),\n      };\n\n    // ------------------------------------\n    // BEST-OF-ALL - Run multiple and pick best\n    // ------------------------------------\n    case 'bestOfAll':\n      return {\n        id: nanoid(),\n        agent: 'bestOfAllAgent',\n        criteria: step.criteria,\n        input: step.steps.map((child) => convertToFlowDefinition(child)),\n      };\n\n    // ------------------------------------\n    // TOOL - Direct tool execution\n    // ------------------------------------\n    case 'tool':\n      return {\n        id: nanoid(),\n        agent: 'toolAgent',\n        input: JSON.stringify({\n          toolName: step.toolName,\n          toolOptions: step.toolOptions,\n        }),\n      };\n\n    // ------------------------------------\n    // UI-COMPONENT - UI rendering step\n    // ------------------------------------\n    case 'uiComponent':\n      return {\n        id: nanoid(),\n        agent: 'uiComponentAgent',\n        input: JSON.stringify({\n          componentName: step.componentName,\n          componentProps: step.componentProps,\n        }),\n      };\n\n    // ------------------------------------\n    // CONDITION - If-then-else\n    // ------------------------------------\n    case 'condition':\n      return {\n        id: nanoid(),\n        agent: 'oneOfAgent',\n        input: [\n          convertToFlowDefinition(step.trueFlow),\n          convertToFlowDefinition(step.falseFlow),\n        ],\n        conditions: [step.condition, `!(${step.condition})`],\n      };\n\n    // ------------------------------------\n    // LOOP - While loop\n    // ------------------------------------\n    case 'loop':\n      return {\n        id: nanoid(),\n        agent: 'forEachAgent',\n        item: 'iteration',\n        input: convertToFlowDefinition(step.loopFlow),\n        maxIterations: step.maxIterations,\n        condition: step.condition,\n      };\n\n    default:\n      return {\n        id: nanoid(),\n        agent: 'unknownAgent',\n        input: '',\n      };\n  }\n}\n\n/**\n * Convert flows-ai FlowDefinition back to EditorStep\n * Useful for round-tripping and editing\n */\nexport function convertFromFlowDefinition(flowDef: any): EditorStep {\n  const agent = flowDef.agent;\n\n  switch (agent) {\n    case 'sequenceAgent':\n      return {\n        type: 'sequence',\n        steps: Array.isArray(flowDef.input)\n          ? flowDef.input.map((child: any) => convertFromFlowDefinition(child))\n          : [],\n      };\n\n    case 'parallelAgent':\n      return {\n        type: 'parallel',\n        steps: Array.isArray(flowDef.input)\n          ? flowDef.input.map((child: any) => convertFromFlowDefinition(child))\n          : [],\n      };\n\n    case 'oneOfAgent':\n      const conditions = flowDef.conditions || [];\n      const flows = Array.isArray(flowDef.input) ? flowDef.input : [];\n      return {\n        type: 'oneOf',\n        branches: flows.map((flow: any, i: number) => ({\n          when: conditions[i] || '',\n          flow: convertFromFlowDefinition(flow),\n        })),\n      };\n\n    case 'forEachAgent':\n      return {\n        type: 'forEach',\n        item: flowDef.item || '',\n        inputFlow: convertFromFlowDefinition(flowDef.input),\n      };\n\n    case 'optimizeAgent':\n      return {\n        type: 'evaluator',\n        criteria: flowDef.criteria || '',\n        max_iterations: flowDef.max_iterations,\n        subFlow: convertFromFlowDefinition(flowDef.input),\n      };\n\n    case 'bestOfAllAgent':\n      return {\n        type: 'bestOfAll',\n        criteria: flowDef.criteria || '',\n        steps: Array.isArray(flowDef.input)\n          ? flowDef.input.map((child: any) => convertFromFlowDefinition(child))\n          : [],\n      };\n\n    case 'toolAgent':\n      try {\n        const parsed = JSON.parse(flowDef.input);\n        return {\n          type: 'tool',\n          toolName: parsed.toolName || '',\n          toolOptions: parsed.toolOptions || {},\n        };\n      } catch {\n        return {\n          type: 'step',\n          agent: 'toolAgent',\n          input: flowDef.input,\n        };\n      }\n\n    case 'uiComponentAgent':\n      try {\n        const parsed = JSON.parse(flowDef.input);\n        return {\n          type: 'uiComponent',\n          componentName: parsed.componentName || '',\n          componentProps: parsed.componentProps || {},\n        };\n      } catch {\n        return {\n          type: 'step',\n          agent: 'uiComponentAgent',\n          input: flowDef.input,\n        };\n      }\n\n    default:\n      return {\n        type: 'step',\n        agent: agent || 'defaultAgent',\n        input: typeof flowDef.input === 'string' ? flowDef.input : JSON.stringify(flowDef.input),\n      };\n  }\n}\n","import { z } from 'zod';\nimport { FlowInputVariable, FlowInputType } from '../types';\n\n/**\n * Extract variable names from a string in the format @variableName\n * Returns array of variable names without the @ prefix\n */\nexport function extractVariableNames(str: string): string[] {\n  const regex = /@([a-zA-Z0-9_]+)/g;\n  const result: string[] = [];\n  let match: RegExpExecArray | null;\n\n  while ((match = regex.exec(str)) !== null) {\n    result.push(match[1]);\n  }\n  return result;\n}\n\n/**\n * Replace all occurrences of @variableName with actual values\n */\nexport function replaceVariablesInString(\n  str: string,\n  variables: Record<string, string>\n): string {\n  let result = str;\n  for (const [name, value] of Object.entries(variables)) {\n    const pattern = new RegExp(`@${name}`, 'g');\n    result = result.replace(pattern, value);\n  }\n  return result;\n}\n\n/**\n * Inject variable values into a flow definition recursively\n */\nexport function injectVariables(\n  flowDef: any,\n  variables: Record<string, string>\n): any {\n  // Replace variables in string input\n  if (typeof flowDef.input === 'string') {\n    flowDef.input = replaceVariablesInString(flowDef.input, variables);\n  }\n\n  // Replace variables in conditions (oneOf)\n  if (Array.isArray(flowDef.conditions)) {\n    flowDef.conditions = flowDef.conditions.map((cond: string) =>\n      replaceVariablesInString(cond, variables)\n    );\n  }\n\n  // Replace variables in criteria (evaluator, bestOfAll)\n  if (typeof flowDef.criteria === 'string') {\n    flowDef.criteria = replaceVariablesInString(flowDef.criteria, variables);\n  }\n\n  // Recursively process nested flows\n  const agent = flowDef.agent;\n  switch (agent) {\n    case 'sequenceAgent':\n    case 'parallelAgent':\n    case 'bestOfAllAgent':\n    case 'oneOfAgent':\n      if (Array.isArray(flowDef.input)) {\n        flowDef.input.forEach((child: any) => injectVariables(child, variables));\n      }\n      break;\n\n    case 'forEachAgent':\n    case 'optimizeAgent':\n      if (flowDef.input && typeof flowDef.input === 'object') {\n        injectVariables(flowDef.input, variables);\n      }\n      break;\n  }\n\n  return flowDef;\n}\n\n/**\n * Apply transformation function to all input fields in flow definition\n */\nexport async function applyInputTransformation(\n  flowDef: any,\n  transformFn: (node: any) => Promise<any> | any\n): Promise<void> {\n  // Transform current node's input\n  flowDef.input = await transformFn(flowDef);\n  \n  // Set name if not present\n  if (!flowDef.name) {\n    flowDef.name = flowDef.agent;\n  }\n\n  // Recursively transform nested nodes\n  const agent = flowDef.agent;\n  switch (agent) {\n    case 'sequenceAgent':\n    case 'parallelAgent':\n    case 'bestOfAllAgent':\n    case 'oneOfAgent':\n      if (Array.isArray(flowDef.input)) {\n        await Promise.all(\n          flowDef.input.map((child: any) =>\n            applyInputTransformation(child, transformFn)\n          )\n        );\n      }\n      break;\n\n    case 'forEachAgent':\n    case 'optimizeAgent':\n      if (flowDef.input && typeof flowDef.input === 'object') {\n        await applyInputTransformation(flowDef.input, transformFn);\n      }\n      break;\n  }\n}\n\n/**\n * Create a dynamic Zod schema from flow input variables\n */\nexport function createDynamicZodSchemaForInputs(options: {\n  availableInputs: FlowInputVariable[];\n}): z.ZodObject<any> {\n  const { availableInputs } = options;\n\n  if (!availableInputs || availableInputs.length === 0) {\n    return z.object({});\n  }\n\n  const shape: Record<string, z.ZodTypeAny> = {};\n\n  for (const inputVar of availableInputs) {\n    let fieldSchema: z.ZodTypeAny;\n\n    switch (inputVar.type) {\n      case 'shortText':\n      case 'longText':\n      case 'url':\n        fieldSchema = z.string().describe(inputVar.description || inputVar.name);\n        break;\n\n      case 'number':\n        fieldSchema = z.number().describe(inputVar.description || inputVar.name);\n        break;\n\n      case 'json':\n        fieldSchema = z.any().describe(inputVar.description || inputVar.name);\n        break;\n\n      case 'fileBase64':\n        fieldSchema = z.string().describe(inputVar.description || inputVar.name);\n        break;\n\n      default:\n        fieldSchema = z.string().describe(inputVar.description || inputVar.name);\n    }\n\n    // Make optional if not required\n    if (!inputVar.required) {\n      fieldSchema = fieldSchema.optional();\n    }\n\n    shape[inputVar.name] = fieldSchema;\n  }\n\n  return z.object(shape);\n}\n\n/**\n * Validate flow input against schema\n */\nexport function validateFlowInput(\n  input: any,\n  variables: FlowInputVariable[]\n): { valid: boolean; errors: string[] } {\n  const errors: string[] = [];\n\n  for (const variable of variables) {\n    if (variable.required && (input[variable.name] === undefined || input[variable.name] === null)) {\n      errors.push(`Required input variable '${variable.name}' is missing`);\n    }\n\n    if (input[variable.name] !== undefined) {\n      const value = input[variable.name];\n\n      // Type validation\n      switch (variable.type) {\n        case 'number':\n          if (typeof value !== 'number') {\n            errors.push(`Input variable '${variable.name}' must be a number`);\n          }\n          break;\n\n        case 'shortText':\n        case 'longText':\n        case 'url':\n        case 'fileBase64':\n          if (typeof value !== 'string') {\n            errors.push(`Input variable '${variable.name}' must be a string`);\n          }\n          break;\n\n        case 'json':\n          // Any type is acceptable\n          break;\n      }\n    }\n  }\n\n  return {\n    valid: errors.length === 0,\n    errors,\n  };\n}\n\n/**\n * Input type labels for UI display\n */\nexport const INPUT_TYPE_LABELS: Record<FlowInputType, string> = {\n  shortText: 'Short text',\n  url: 'URL',\n  longText: 'Long text',\n  number: 'Number',\n  json: 'JSON Object',\n  fileBase64: 'File (Base64)',\n};\n","import { AgentFlow, FlowAgentDefinition } from '../types';\n\n/**\n * Validate flow configuration\n */\nexport function validateFlow(flow: Partial<AgentFlow>): {\n  valid: boolean;\n  errors: string[];\n} {\n  const errors: string[] = [];\n\n  if (!flow.code) {\n    errors.push('Flow code is required');\n  }\n\n  if (!flow.name) {\n    errors.push('Flow name is required');\n  }\n\n  // Validate input variables\n  if (flow.inputs) {\n    const names = new Set<string>();\n    for (const input of flow.inputs) {\n      if (!input.name) {\n        errors.push('Input variable name is required');\n      } else {\n        if (names.has(input.name)) {\n          errors.push(`Duplicate input variable name: ${input.name}`);\n        }\n        names.add(input.name);\n      }\n\n      if (!input.type) {\n        errors.push(`Input variable '${input.name}' must have a type`);\n      }\n    }\n  }\n\n  // Validate agents\n  if (flow.agents) {\n    const agentNames = new Set<string>();\n    for (const agent of flow.agents) {\n      if (!agent.name) {\n        errors.push('Agent name is required');\n      } else {\n        if (agentNames.has(agent.name)) {\n          errors.push(`Duplicate agent name: ${agent.name}`);\n        }\n        agentNames.add(agent.name);\n      }\n\n      if (!agent.model) {\n        errors.push(`Agent '${agent.name}' must have a model specified`);\n      }\n\n      if (!agent.system) {\n        errors.push(`Agent '${agent.name}' must have a system prompt`);\n      }\n    }\n  }\n\n  return {\n    valid: errors.length === 0,\n    errors,\n  };\n}\n\n/**\n * Validate agent definition\n */\nexport function validateAgentDefinition(agent: Partial<FlowAgentDefinition>): {\n  valid: boolean;\n  errors: string[];\n} {\n  const errors: string[] = [];\n\n  if (!agent.name) {\n    errors.push('Agent name is required');\n  }\n\n  if (!agent.model) {\n    errors.push('Agent model is required');\n  }\n\n  if (!agent.system) {\n    errors.push('Agent system prompt is required');\n  }\n\n  return {\n    valid: errors.length === 0,\n    errors,\n  };\n}\n","/**\n * Domain Models\n * Pure TypeScript classes representing business entities\n * Framework-agnostic and database-agnostic\n */\n\nimport { AgentConfig, AgentFlow } from '../types';\n\n/**\n * Agent Domain Model\n */\nexport class Agent {\n  id?: string;\n  name: string;\n  agentType: string;\n  locale: string;\n  prompt?: string;\n  expectedResult?: any;\n  tools?: Record<string, any>;\n  flows?: AgentFlow[];\n  events?: any[];\n  settings?: Record<string, any>;\n  metadata?: Record<string, any>;\n  createdAt?: string;\n  updatedAt?: string;\n\n  constructor(config: AgentConfig & { createdAt?: string; updatedAt?: string }) {\n    this.id = config.id;\n    this.name = config.name;\n    this.agentType = config.agentType;\n    this.locale = config.locale || 'en';\n    this.prompt = config.prompt;\n    this.expectedResult = config.expectedResult;\n    this.tools = config.tools;\n    this.flows = config.flows;\n    this.events = config.events;\n    this.settings = config.settings;\n    this.metadata = config.metadata;\n    this.createdAt = config.createdAt;\n    this.updatedAt = config.updatedAt;\n  }\n\n  /**\n   * Convert to AgentConfig for SDK usage\n   */\n  toConfig(): AgentConfig {\n    return {\n      id: this.id,\n      name: this.name,\n      agentType: this.agentType as any,\n      locale: this.locale,\n      prompt: this.prompt,\n      expectedResult: this.expectedResult,\n      tools: this.tools,\n      flows: this.flows,\n      events: this.events,\n      settings: this.settings,\n      metadata: this.metadata,\n    };\n  }\n\n  /**\n   * Create from AgentConfig\n   */\n  static fromConfig(config: AgentConfig): Agent {\n    return new Agent(config);\n  }\n}\n\n/**\n * Session Domain Model\n */\nexport class Session {\n  id: string;\n  agentId: string;\n  data?: Record<string, any>;\n  messages?: any[];\n  createdAt: string;\n  updatedAt: string;\n\n  constructor(data: {\n    id: string;\n    agentId: string;\n    data?: Record<string, any>;\n    messages?: any[];\n    createdAt?: string;\n    updatedAt?: string;\n  }) {\n    this.id = data.id;\n    this.agentId = data.agentId;\n    this.data = data.data;\n    this.messages = data.messages;\n    this.createdAt = data.createdAt || new Date().toISOString();\n    this.updatedAt = data.updatedAt || new Date().toISOString();\n  }\n}\n\n/**\n * Result Domain Model\n */\nexport class Result {\n  id?: string;\n  sessionId: string;\n  agentId: string;\n  result: any;\n  success: boolean;\n  error?: string;\n  tokensUsed?: number;\n  duration?: number;\n  createdAt: string;\n\n  constructor(data: {\n    id?: string;\n    sessionId: string;\n    agentId: string;\n    result: any;\n    success: boolean;\n    error?: string;\n    tokensUsed?: number;\n    duration?: number;\n    createdAt?: string;\n  }) {\n    this.id = data.id;\n    this.sessionId = data.sessionId;\n    this.agentId = data.agentId;\n    this.result = data.result;\n    this.success = data.success;\n    this.error = data.error;\n    this.tokensUsed = data.tokensUsed;\n    this.duration = data.duration;\n    this.createdAt = data.createdAt || new Date().toISOString();\n  }\n}\n\n/**\n * Memory Domain Model\n */\nexport class Memory {\n  id?: string;\n  agentId: string;\n  sessionId?: string;\n  content: string;\n  embedding?: number[];\n  metadata?: Record<string, any>;\n  createdAt: string;\n\n  constructor(data: {\n    id?: string;\n    agentId: string;\n    sessionId?: string;\n    content: string;\n    embedding?: number[];\n    metadata?: Record<string, any>;\n    createdAt?: string;\n  }) {\n    this.id = data.id;\n    this.agentId = data.agentId;\n    this.sessionId = data.sessionId;\n    this.content = data.content;\n    this.embedding = data.embedding;\n    this.metadata = data.metadata;\n    this.createdAt = data.createdAt || new Date().toISOString();\n  }\n\n  /**\n   * Convenience getter for importance (from metadata)\n   */\n  get importance(): number {\n    return this.metadata?.importance ?? 1;\n  }\n\n  /**\n   * Convenience getter for access count (from metadata)\n   */\n  get accessCount(): number {\n    return this.metadata?.accessCount ?? 0;\n  }\n\n  /**\n   * Convenience getter for accessed at (from metadata)\n   */\n  get accessedAt(): string | undefined {\n    return this.metadata?.accessedAt;\n  }\n}\n\n/**\n * Attachment Domain Model\n */\nexport class Attachment {\n  id?: number;\n  displayName: string;\n  description?: string;\n  mimeType?: string;\n  type?: string;\n  size: number;\n  storageKey: string;\n  filePath?: string;\n  content?: string;\n  metadata?: Record<string, any>;\n  createdAt: string;\n  updatedAt: string;\n\n  constructor(data: {\n    id?: number;\n    displayName: string;\n    description?: string;\n    mimeType?: string;\n    type?: string;\n    size: number;\n    storageKey: string;\n    filePath?: string;\n    content?: string;\n    metadata?: Record<string, any>;\n    createdAt?: string;\n    updatedAt?: string;\n  }) {\n    this.id = data.id;\n    this.displayName = data.displayName;\n    this.description = data.description;\n    this.mimeType = data.mimeType;\n    this.type = data.type;\n    this.size = data.size;\n    this.storageKey = data.storageKey;\n    this.filePath = data.filePath;\n    this.content = data.content;\n    this.metadata = data.metadata;\n    this.createdAt = data.createdAt || new Date().toISOString();\n    this.updatedAt = data.updatedAt || new Date().toISOString();\n  }\n}\n","/**\n * Mock Repository Implementations\n * In-memory implementations for testing and development\n */\n\nimport {\n  AgentRepository,\n  SessionRepository,\n  ResultRepository,\n  MemoryRepository,\n  AttachmentRepository,\n  PaginationOptions,\n  PaginatedResult,\n} from './repositories';\nimport { Agent, Session, Result, Memory, Attachment } from './models';\nimport { nanoid } from 'nanoid';\n\n/**\n * Base Mock Repository\n * Provides in-memory storage for testing\n */\nabstract class BaseMockRepository<T extends { id?: any; createdAt?: string; updatedAt?: string }, TId = string> {\n  protected items: Map<TId, T> = new Map();\n\n  async findById(id: TId): Promise<T | null> {\n    return this.items.get(id) || null;\n  }\n\n  async findMany(filter?: Partial<T>): Promise<T[]> {\n    const items = Array.from(this.items.values());\n    if (!filter) return items;\n\n    return items.filter(item => {\n      return Object.entries(filter).every(([key, value]) => {\n        return item[key as keyof T] === value;\n      });\n    });\n  }\n\n  async create(data: any): Promise<T> {\n    const id = this.generateId();\n    const now = new Date().toISOString();\n    const item = {\n      ...data,\n      id,\n      createdAt: now,\n      updatedAt: now,\n    } as T;\n    this.items.set(id as TId, item);\n    return item;\n  }\n\n  async update(id: TId, data: Partial<T>): Promise<T> {\n    const existing = this.items.get(id);\n    if (!existing) {\n      throw new Error(`Item with id ${id} not found`);\n    }\n\n    const updated = {\n      ...existing,\n      ...data,\n      updatedAt: new Date().toISOString(),\n    } as T;\n    this.items.set(id, updated);\n    return updated;\n  }\n\n  async delete(id: TId): Promise<boolean> {\n    return this.items.delete(id);\n  }\n\n  async count(filter?: Partial<T>): Promise<number> {\n    const items = await this.findMany(filter);\n    return items.length;\n  }\n\n  protected abstract generateId(): TId;\n\n  clear(): void {\n    this.items.clear();\n  }\n}\n\n/**\n * Mock Agent Repository\n */\nexport class MockAgentRepository\n  extends BaseMockRepository<Agent, string>\n  implements AgentRepository\n{\n  protected generateId(): string {\n    return nanoid();\n  }\n\n  async findByType(type: string): Promise<Agent[]> {\n    return Array.from(this.items.values()).filter(\n      agent => agent.agentType === type\n    );\n  }\n\n  async findByName(name: string): Promise<Agent | null> {\n    const items = Array.from(this.items.values());\n    return items.find(agent => agent.name === name) || null;\n  }\n\n  async search(query: string): Promise<Agent[]> {\n    const lowerQuery = query.toLowerCase();\n    return Array.from(this.items.values()).filter(agent =>\n      agent.name.toLowerCase().includes(lowerQuery) ||\n      agent.prompt?.toLowerCase().includes(lowerQuery)\n    );\n  }\n\n  async findWithPagination(options: PaginationOptions): Promise<PaginatedResult<Agent>> {\n    const { page = 1, perPage = 10 } = options;\n    const items = Array.from(this.items.values());\n    const total = items.length;\n    const start = (page - 1) * perPage;\n    const end = start + perPage;\n    const data = items.slice(start, end);\n\n    return {\n      data,\n      total,\n      page,\n      perPage,\n      totalPages: Math.ceil(total / perPage),\n      hasMore: end < total,\n    };\n  }\n}\n\n/**\n * Mock Session Repository\n */\nexport class MockSessionRepository\n  extends BaseMockRepository<Session, string>\n  implements SessionRepository\n{\n  protected generateId(): string {\n    return nanoid();\n  }\n\n  async findByAgentId(agentId: string): Promise<Session[]> {\n    return Array.from(this.items.values()).filter(\n      session => session.agentId === agentId\n    );\n  }\n\n  async findWithMessages(sessionId: string): Promise<Session | null> {\n    return this.findById(sessionId);\n  }\n\n  async addMessage(sessionId: string, message: any): Promise<Session> {\n    const session = await this.findById(sessionId);\n    if (!session) {\n      throw new Error(`Session ${sessionId} not found`);\n    }\n\n    const messages = session.messages || [];\n    return this.update(sessionId, {\n      messages: [...messages, message],\n    });\n  }\n\n  async updateData(sessionId: string, data: Record<string, any>): Promise<Session> {\n    const session = await this.findById(sessionId);\n    if (!session) {\n      throw new Error(`Session ${sessionId} not found`);\n    }\n\n    return this.update(sessionId, {\n      data: { ...session.data, ...data },\n    });\n  }\n}\n\n/**\n * Mock Result Repository\n */\nexport class MockResultRepository\n  extends BaseMockRepository<Result, string>\n  implements ResultRepository\n{\n  protected generateId(): string {\n    return nanoid();\n  }\n\n  async findBySessionId(sessionId: string): Promise<Result | null> {\n    const items = Array.from(this.items.values());\n    return items.find(result => result.sessionId === sessionId) || null;\n  }\n\n  async findByAgentId(agentId: string): Promise<Result[]> {\n    return Array.from(this.items.values()).filter(\n      result => result.agentId === agentId\n    );\n  }\n\n  async findSuccessful(): Promise<Result[]> {\n    return Array.from(this.items.values()).filter(result => result.success);\n  }\n\n  async findFailed(): Promise<Result[]> {\n    return Array.from(this.items.values()).filter(result => !result.success);\n  }\n}\n\n/**\n * Mock Memory Repository\n */\nexport class MockMemoryRepository\n  extends BaseMockRepository<Memory, string>\n  implements MemoryRepository\n{\n  protected generateId(): string {\n    return nanoid();\n  }\n\n  /**\n   * Override create to return Memory class instances\n   */\n  async create(data: any): Promise<Memory> {\n    const id = this.generateId();\n    const now = new Date().toISOString();\n    const memory = new Memory({\n      ...data,\n      id,\n      createdAt: data.createdAt || now,\n    });\n    this.items.set(id, memory);\n    return memory;\n  }\n\n  /**\n   * Override update to maintain Memory class instances\n   */\n  async update(id: string, data: Partial<Memory>): Promise<Memory> {\n    const existing = this.items.get(id);\n    if (!existing) {\n      throw new Error(`Memory with id ${id} not found`);\n    }\n\n    const updated = new Memory({\n      ...existing,\n      ...data,\n      id: existing.id,\n      agentId: data.agentId || existing.agentId,\n      content: data.content || existing.content,\n      createdAt: existing.createdAt,\n    });\n    \n    this.items.set(id, updated);\n    return updated;\n  }\n\n  async findByAgentId(agentId: string, limit?: number): Promise<Memory[]> {\n    const memories = Array.from(this.items.values()).filter(\n      memory => memory.agentId === agentId\n    );\n    return limit ? memories.slice(0, limit) : memories;\n  }\n\n  async findBySessionId(sessionId: string): Promise<Memory[]> {\n    return Array.from(this.items.values()).filter(\n      memory => memory.sessionId === sessionId\n    );\n  }\n\n  async search(agentId: string, query: string, limit = 10): Promise<Memory[]> {\n    const lowerQuery = query.toLowerCase();\n    const memories = Array.from(this.items.values()).filter(\n      memory =>\n        memory.agentId === agentId &&\n        memory.content.toLowerCase().includes(lowerQuery)\n    );\n    return memories.slice(0, limit);\n  }\n\n  async searchByEmbedding(\n    agentId: string,\n    embedding: number[],\n    limit = 10\n  ): Promise<Memory[]> {\n    // Simple cosine similarity search\n    const memories = Array.from(this.items.values())\n      .filter(memory => memory.agentId === agentId && memory.embedding)\n      .map(memory => ({\n        memory,\n        similarity: this.cosineSimilarity(embedding, memory.embedding!),\n      }))\n      .sort((a, b) => b.similarity - a.similarity)\n      .slice(0, limit)\n      .map(item => item.memory);\n\n    return memories;\n  }\n\n  private cosineSimilarity(a: number[], b: number[]): number {\n    const dotProduct = a.reduce((sum, val, i) => sum + val * b[i], 0);\n    const magA = Math.sqrt(a.reduce((sum, val) => sum + val * val, 0));\n    const magB = Math.sqrt(b.reduce((sum, val) => sum + val * val, 0));\n    return dotProduct / (magA * magB);\n  }\n}\n\n/**\n * Mock Attachment Repository\n */\nexport class MockAttachmentRepository\n  extends BaseMockRepository<Attachment, number>\n  implements AttachmentRepository\n{\n  private nextId = 1;\n\n  protected generateId(): number {\n    return this.nextId++;\n  }\n\n  async findByStorageKey(storageKey: string): Promise<Attachment | null> {\n    const items = Array.from(this.items.values());\n    return items.find(att => att.storageKey === storageKey) || null;\n  }\n\n  async findByType(type: string): Promise<Attachment[]> {\n    return Array.from(this.items.values()).filter(att => att.type === type);\n  }\n\n  async findWithContent(id: number): Promise<Attachment | null> {\n    return this.findById(id);\n  }\n}\n","/**\n * LLM Provider Abstraction\n * Framework-agnostic interface for LLM providers\n */\n\n/**\n * Message role types\n */\nexport type MessageRole = 'system' | 'user' | 'assistant' | 'tool';\n\n/**\n * Message structure\n */\nexport interface Message {\n  role: MessageRole;\n  content: string;\n  name?: string;\n  toolCallId?: string;\n  toolCalls?: ToolCall[];\n}\n\n/**\n * Tool call structure\n */\nexport interface ToolCall {\n  id: string;\n  type: 'function';\n  function: {\n    name: string;\n    arguments: string;\n  };\n}\n\n/**\n * Tool definition\n */\nexport interface ToolDefinition {\n  type: 'function';\n  function: {\n    name: string;\n    description: string;\n    parameters: Record<string, any>;\n  };\n}\n\n/**\n * Generation options\n */\nexport interface GenerateOptions {\n  model: string;\n  messages: Message[];\n  temperature?: number;\n  maxTokens?: number;\n  topP?: number;\n  frequencyPenalty?: number;\n  presencePenalty?: number;\n  stop?: string[];\n  tools?: ToolDefinition[];\n  toolChoice?: 'auto' | 'required' | 'none' | { type: 'function'; function: { name: string } };\n  seed?: number;\n}\n\n/**\n * Generation result\n */\nexport interface GenerateResult {\n  text: string;\n  finishReason: 'stop' | 'length' | 'tool_calls' | 'content_filter' | 'error';\n  usage: {\n    promptTokens: number;\n    completionTokens: number;\n    totalTokens: number;\n  };\n  toolCalls?: ToolCall[];\n  rawResponse?: any;\n}\n\n/**\n * Stream chunk types\n */\nexport type StreamChunkType = \n  | 'text-delta'\n  | 'tool-call'\n  | 'tool-result'\n  | 'finish'\n  | 'error';\n\n/**\n * Stream chunk\n */\nexport interface StreamChunk {\n  type: StreamChunkType;\n  textDelta?: string;\n  toolCall?: ToolCall;\n  toolResult?: {\n    toolCallId: string;\n    result: any;\n  };\n  finishReason?: string;\n  usage?: {\n    promptTokens: number;\n    completionTokens: number;\n    totalTokens: number;\n  };\n  error?: Error;\n}\n\n/**\n * Stream result\n */\nexport interface StreamResult {\n  textStream: AsyncIterable<string>;\n  fullStream: AsyncIterable<StreamChunk>;\n  text: Promise<string>;\n  usage: Promise<{\n    promptTokens: number;\n    completionTokens: number;\n    totalTokens: number;\n  }>;\n  finishReason: Promise<string>;\n  toolCalls: Promise<ToolCall[]>;\n}\n\n/**\n * LLM Provider interface\n */\nexport interface LLMProvider {\n  /**\n   * Provider name (e.g., 'openai', 'anthropic', 'ollama')\n   */\n  readonly name: string;\n\n  /**\n   * Generate text without streaming\n   */\n  generate(options: GenerateOptions): Promise<GenerateResult>;\n\n  /**\n   * Generate text with streaming\n   */\n  stream(options: GenerateOptions): Promise<StreamResult>;\n\n  /**\n   * Check if model supports tools\n   */\n  supportsTools(model: string): boolean;\n\n  /**\n   * Check if model supports streaming\n   */\n  supportsStreaming(model: string): boolean;\n\n  /**\n   * Get available models\n   */\n  getModels(): Promise<string[]>;\n}\n\n/**\n * LLM Provider configuration\n */\nexport interface LLMProviderConfig {\n  name: string;\n  apiKey?: string;\n  baseURL?: string;\n  defaultModel?: string;\n  timeout?: number;\n  maxRetries?: number;\n  headers?: Record<string, string>;\n  [key: string]: any;\n}\n\n/**\n * Provider factory function type\n */\nexport type ProviderFactory = (config: LLMProviderConfig) => LLMProvider;\n\n/**\n * Provider registry\n */\nexport class LLMProviderRegistry {\n  private static providers = new Map<string, ProviderFactory>();\n\n  /**\n   * Register a provider\n   */\n  static register(name: string, factory: ProviderFactory): void {\n    this.providers.set(name.toLowerCase(), factory);\n  }\n\n  /**\n   * Create provider instance\n   */\n  static create(name: string, config: LLMProviderConfig): LLMProvider {\n    const factory = this.providers.get(name.toLowerCase());\n    if (!factory) {\n      throw new Error(`Provider '${name}' not found. Available: ${Array.from(this.providers.keys()).join(', ')}`);\n    }\n    return factory(config);\n  }\n\n  /**\n   * Check if provider is registered\n   */\n  static has(name: string): boolean {\n    return this.providers.has(name.toLowerCase());\n  }\n\n  /**\n   * Get all registered provider names\n   */\n  static getProviderNames(): string[] {\n    return Array.from(this.providers.keys());\n  }\n\n  /**\n   * Clear all providers (for testing)\n   */\n  static clear(): void {\n    this.providers.clear();\n  }\n}\n","/**\n * Mock LLM Provider\n * For testing and development\n */\n\nimport {\n  LLMProvider,\n  LLMProviderConfig,\n  GenerateOptions,\n  GenerateResult,\n  StreamResult,\n  StreamChunk,\n  ToolCall,\n} from './llm';\n\n/**\n * Mock response configuration\n */\nexport interface MockProviderConfig extends LLMProviderConfig {\n  responses?: string[];\n  delay?: number;\n  simulateError?: boolean;\n  errorMessage?: string;\n}\n\n/**\n * Mock LLM Provider\n */\nexport class MockLLMProvider implements LLMProvider {\n  readonly name = 'mock';\n  private responseIndex = 0;\n  private responses: string[];\n  private delay: number;\n  private simulateError: boolean;\n  private errorMessage: string;\n\n  constructor(config: MockProviderConfig) {\n    this.responses = config.responses || ['This is a mock response.'];\n    this.delay = config.delay || 0;\n    this.simulateError = config.simulateError || false;\n    this.errorMessage = config.errorMessage || 'Mock error';\n  }\n\n  async generate(options: GenerateOptions): Promise<GenerateResult> {\n    if (this.simulateError) {\n      throw new Error(this.errorMessage);\n    }\n\n    if (this.delay > 0) {\n      await new Promise(resolve => setTimeout(resolve, this.delay));\n    }\n\n    const text = this.getNextResponse();\n    const toolCalls = this.extractToolCalls(options);\n\n    return {\n      text,\n      finishReason: toolCalls.length > 0 ? 'tool_calls' : 'stop',\n      usage: {\n        promptTokens: this.countTokens(options.messages),\n        completionTokens: this.countTokens([{ role: 'assistant', content: text }]),\n        totalTokens: this.countTokens(options.messages) + this.countTokens([{ role: 'assistant', content: text }]),\n      },\n      toolCalls: toolCalls.length > 0 ? toolCalls : undefined,\n    };\n  }\n\n  async stream(options: GenerateOptions): Promise<StreamResult> {\n    if (this.simulateError) {\n      throw new Error(this.errorMessage);\n    }\n\n    const text = this.getNextResponse();\n    const words = text.split(' ');\n    const chunks: StreamChunk[] = [];\n\n    const fullStreamGenerator = async function* (\n      this: MockLLMProvider\n    ): AsyncGenerator<StreamChunk> {\n      for (const word of words) {\n        if (this.delay > 0) {\n          await new Promise(resolve => setTimeout(resolve, this.delay));\n        }\n\n        const chunk: StreamChunk = {\n          type: 'text-delta',\n          textDelta: word + ' ',\n        };\n        chunks.push(chunk);\n        yield chunk;\n      }\n\n      yield {\n        type: 'finish',\n        finishReason: 'stop',\n        usage: {\n          promptTokens: this.countTokens(options.messages),\n          completionTokens: words.length,\n          totalTokens: this.countTokens(options.messages) + words.length,\n        },\n      };\n    }.bind(this);\n\n    const textStreamGenerator = async function* (): AsyncGenerator<string> {\n      for (const word of words) {\n        yield word + ' ';\n      }\n    };\n\n    return {\n      fullStream: fullStreamGenerator(),\n      textStream: textStreamGenerator(),\n      text: Promise.resolve(text),\n      usage: Promise.resolve({\n        promptTokens: this.countTokens(options.messages),\n        completionTokens: words.length,\n        totalTokens: this.countTokens(options.messages) + words.length,\n      }),\n      finishReason: Promise.resolve('stop'),\n      toolCalls: Promise.resolve([]),\n    };\n  }\n\n  supportsTools(model: string): boolean {\n    return true;\n  }\n\n  supportsStreaming(model: string): boolean {\n    return true;\n  }\n\n  async getModels(): Promise<string[]> {\n    return ['mock-model-1', 'mock-model-2'];\n  }\n\n  private getNextResponse(): string {\n    const response = this.responses[this.responseIndex % this.responses.length];\n    this.responseIndex++;\n    return response;\n  }\n\n  private extractToolCalls(options: GenerateOptions): ToolCall[] {\n    // Simple mock: if tools are defined and message mentions tool name, simulate a call\n    if (!options.tools || options.tools.length === 0) {\n      return [];\n    }\n\n    const lastMessage = options.messages[options.messages.length - 1];\n    if (!lastMessage || lastMessage.role !== 'user') {\n      return [];\n    }\n\n    // Check if message mentions any tool name\n    for (const tool of options.tools) {\n      if (lastMessage.content.toLowerCase().includes(tool.function.name.toLowerCase())) {\n        return [\n          {\n            id: `call_${Date.now()}`,\n            type: 'function',\n            function: {\n              name: tool.function.name,\n              arguments: JSON.stringify({ input: 'mock input' }),\n            },\n          },\n        ];\n      }\n    }\n\n    return [];\n  }\n\n  private countTokens(messages: any[]): number {\n    // Simple approximation: 1 token per 4 characters\n    return Math.ceil(\n      messages.reduce((sum, msg) => sum + (msg.content?.length || 0), 0) / 4\n    );\n  }\n}\n\n/**\n * Create mock provider\n */\nexport function createMockProvider(config: MockProviderConfig = { name: 'mock' }): MockLLMProvider {\n  return new MockLLMProvider(config);\n}\n","/**\n * OpenAI Provider Implementation\n * Uses the 'ai' SDK for unified interface\n */\n\nimport { createOpenAI } from '@ai-sdk/openai';\nimport { generateText, streamText, tool as aiTool, CoreMessage } from 'ai';\nimport {\n  LLMProvider,\n  GenerateOptions,\n  GenerateResult,\n  StreamResult,\n  StreamChunk,\n  LLMProviderConfig,\n  Message,\n} from './llm';\n\nexport interface OpenAIProviderConfig extends LLMProviderConfig {\n  apiKey: string;\n  organization?: string;\n  baseURL?: string;\n  defaultModel?: string;\n}\n\n/**\n * Convert our Message type to 'ai' SDK CoreMessage\n */\nfunction convertMessages(messages: Message[]): any[] {\n  return messages.map((msg) => {\n    if (msg.role === 'tool') {\n      return {\n        role: 'tool',\n        content: [\n          {\n            type: 'tool-result',\n            toolCallId: msg.toolCallId || '',\n            toolName: msg.name || 'unknown',\n            result: msg.content,\n          },\n        ],\n      };\n    }\n    // For other roles, return as-is\n    return {\n      role: msg.role,\n      content: msg.content,\n      ...(msg.toolCalls && { toolCalls: msg.toolCalls }),\n    };\n  });\n}\n\n/**\n * OpenAI Provider using the 'ai' SDK\n */\nexport class OpenAIProvider implements LLMProvider {\n  readonly name = 'openai';\n  private provider: ReturnType<typeof createOpenAI>;\n  private config: OpenAIProviderConfig;\n\n  constructor(config: OpenAIProviderConfig) {\n    this.config = config;\n    this.provider = createOpenAI({\n      apiKey: config.apiKey,\n      organization: config.organization,\n      baseURL: config.baseURL,\n      headers: config.headers,\n    });\n  }\n\n  /**\n   * Generate text without streaming\n   */\n  async generate(options: GenerateOptions): Promise<GenerateResult> {\n    const model = this.provider(options.model || this.config.defaultModel || 'gpt-4');\n\n    // Convert tools if provided\n    const tools: Record<string, any> = {};\n    if (options.tools) {\n      for (const toolDef of options.tools) {\n        const params = toolDef.function.parameters;\n        tools[toolDef.function.name] = aiTool({\n          description: toolDef.function.description,\n          parameters: params as any,\n          execute: async () => {\n            // This is just a placeholder, actual execution happens in AgentExecutor\n            return null;\n          },\n        });\n      }\n    }\n\n    const result = await generateText({\n      model,\n      messages: convertMessages(options.messages) as any,\n      temperature: options.temperature,\n      maxTokens: options.maxTokens,\n      topP: options.topP,\n      frequencyPenalty: options.frequencyPenalty,\n      presencePenalty: options.presencePenalty,\n      seed: options.seed,\n      tools: Object.keys(tools).length > 0 ? tools : undefined,\n      maxSteps: 1, // Single step for non-streaming\n    });\n\n    // Convert tool calls from 'ai' SDK format to our format\n    const toolCalls = result.toolCalls?.map((tc: any) => ({\n      id: tc.toolCallId,\n      type: 'function' as const,\n      function: {\n        name: tc.toolName,\n        arguments: JSON.stringify(tc.args),\n      },\n    }));\n\n    return {\n      text: result.text,\n      finishReason: result.finishReason === 'stop' ? 'stop' :\n                    result.finishReason === 'length' ? 'length' :\n                    result.finishReason === 'tool-calls' ? 'tool_calls' :\n                    result.finishReason === 'content-filter' ? 'content_filter' : 'error',\n      usage: {\n        promptTokens: result.usage.promptTokens,\n        completionTokens: result.usage.completionTokens,\n        totalTokens: result.usage.totalTokens,\n      },\n      toolCalls,\n      rawResponse: result,\n    };\n  }\n\n  /**\n   * Generate text with streaming\n   */\n  async stream(options: GenerateOptions): Promise<StreamResult> {\n    const model = this.provider(options.model || this.config.defaultModel || 'gpt-4');\n\n    // Convert tools if provided\n    const tools: Record<string, any> = {};\n    if (options.tools) {\n      for (const toolDef of options.tools) {\n        const params = toolDef.function.parameters;\n        tools[toolDef.function.name] = aiTool({\n          description: toolDef.function.description,\n          parameters: params as any,\n          execute: async () => {\n            // This is just a placeholder, actual execution happens in AgentExecutor\n            return null;\n          },\n        });\n      }\n    }\n\n    const result = await streamText({\n      model,\n      messages: convertMessages(options.messages) as any,\n      temperature: options.temperature,\n      maxTokens: options.maxTokens,\n      topP: options.topP,\n      frequencyPenalty: options.frequencyPenalty,\n      presencePenalty: options.presencePenalty,\n      seed: options.seed,\n      tools: Object.keys(tools).length > 0 ? tools : undefined,\n      maxSteps: 1, // Single step for streaming\n    });\n\n    // Create text stream\n    const textStream = (async function* () {\n      for await (const delta of result.textStream) {\n        yield delta;\n      }\n    })();\n\n    // Create full stream with all event types\n    const fullStream = (async function* () {\n      for await (const delta of result.textStream) {\n        const chunk: StreamChunk = {\n          type: 'text-delta',\n          textDelta: delta,\n        };\n        yield chunk;\n      }\n\n      // Wait for final result to get usage stats\n      const [finalText, finalUsage, finalReason] = await Promise.all([\n        result.text,\n        result.usage,\n        result.finishReason,\n      ]);\n\n      // Emit finish event\n      const chunk: StreamChunk = {\n        type: 'finish',\n        finishReason: finalReason,\n        usage: {\n          promptTokens: finalUsage.promptTokens,\n          completionTokens: finalUsage.completionTokens,\n          totalTokens: finalUsage.totalTokens,\n        },\n      };\n      yield chunk;\n    })();\n\n    // Return promises for final values\n    return {\n      textStream,\n      fullStream,\n      text: (async () => {\n        const finalText = await result.text;\n        return finalText;\n      })(),\n      usage: (async () => {\n        const finalUsage = await result.usage;\n        return {\n          promptTokens: finalUsage.promptTokens,\n          completionTokens: finalUsage.completionTokens,\n          totalTokens: finalUsage.totalTokens,\n        };\n      })(),\n      finishReason: (async () => {\n        const reason = await result.finishReason;\n        return reason;\n      })(),\n      toolCalls: (async () => {\n        const calls = await result.toolCalls;\n        return calls.map((tc: any) => ({\n          id: tc.toolCallId,\n          type: 'function' as const,\n          function: {\n            name: tc.toolName,\n            arguments: JSON.stringify(tc.args),\n          },\n        }));\n      })(),\n    };\n  }\n\n  /**\n   * Check if model supports tools\n   */\n  supportsTools(model: string): boolean {\n    // Most GPT models support tools\n    return model.startsWith('gpt-4') || model.startsWith('gpt-3.5-turbo');\n  }\n\n  /**\n   * Check if model supports streaming\n   */\n  supportsStreaming(model: string): boolean {\n    return true; // All OpenAI models support streaming\n  }\n\n  /**\n   * Get available models\n   */\n  async getModels(): Promise<string[]> {\n    // Return common models (fetching from API requires additional setup)\n    return [\n      'gpt-4',\n      'gpt-4-turbo',\n      'gpt-4o',\n      'gpt-4o-mini',\n      'gpt-3.5-turbo',\n    ];\n  }\n}\n","/**\n * Ollama Provider Implementation\n * Uses the 'ai' SDK with ollama-ai-provider\n */\n\nimport { createOllama } from 'ollama-ai-provider';\nimport { generateText, streamText, tool as aiTool, CoreMessage } from 'ai';\nimport {\n  LLMProvider,\n  GenerateOptions,\n  GenerateResult,\n  StreamResult,\n  StreamChunk,\n  LLMProviderConfig,\n  Message,\n} from './llm';\n\nexport interface OllamaProviderConfig extends LLMProviderConfig {\n  baseURL?: string;\n  defaultModel?: string;\n}\n\n/**\n * Convert our Message type to 'ai' SDK CoreMessage\n */\nfunction convertMessages(messages: Message[]): any[] {\n  return messages.map((msg) => {\n    if (msg.role === 'tool') {\n      return {\n        role: 'tool',\n        content: [\n          {\n            type: 'tool-result',\n            toolCallId: msg.toolCallId || '',\n            toolName: msg.name || 'unknown',\n            result: msg.content,\n          },\n        ],\n      };\n    }\n    // For other roles, return as-is\n    return {\n      role: msg.role,\n      content: msg.content,\n      ...(msg.toolCalls && { toolCalls: msg.toolCalls }),\n    };\n  });\n}\n\n/**\n * Ollama Provider using the 'ai' SDK\n */\nexport class OllamaProvider implements LLMProvider {\n  readonly name = 'ollama';\n  private provider: ReturnType<typeof createOllama>;\n  private config: OllamaProviderConfig;\n\n  constructor(config: OllamaProviderConfig) {\n    this.config = config;\n    this.provider = createOllama({\n      baseURL: config.baseURL || 'http://localhost:11434',\n    });\n  }\n\n  /**\n   * Generate text without streaming\n   */\n  async generate(options: GenerateOptions): Promise<GenerateResult> {\n    const model = this.provider(\n      options.model || this.config.defaultModel || 'llama3.1',\n      {\n        simulateStreaming: true,\n        structuredOutputs: true,\n      }\n    );\n\n    // Convert tools if provided - create Zod schemas on the fly\n    const tools: Record<string, any> = {};\n    if (options.tools) {\n      for (const toolDef of options.tools) {\n        // Convert parameters to Zod schema if needed\n        const params = toolDef.function.parameters;\n        tools[toolDef.function.name] = aiTool({\n          description: toolDef.function.description,\n          parameters: params as any, // Type assertion since we know it's compatible\n          execute: async () => {\n            // This is just a placeholder, actual execution happens in AgentExecutor\n            return null;\n          },\n        });\n      }\n    }\n\n    const result = await generateText({\n      model,\n      messages: convertMessages(options.messages) as any,\n      temperature: options.temperature,\n      maxTokens: options.maxTokens,\n      topP: options.topP,\n      frequencyPenalty: options.frequencyPenalty,\n      presencePenalty: options.presencePenalty,\n      seed: options.seed,\n      tools: Object.keys(tools).length > 0 ? tools : undefined,\n      maxSteps: 1, // Single step for non-streaming\n    });\n\n    // Convert tool calls from 'ai' SDK format to our format\n    const toolCalls = result.toolCalls?.map((tc: any) => ({\n      id: tc.toolCallId,\n      type: 'function' as const,\n      function: {\n        name: tc.toolName,\n        arguments: JSON.stringify(tc.args),\n      },\n    }));\n\n    return {\n      text: result.text,\n      finishReason: result.finishReason === 'stop' ? 'stop' :\n                    result.finishReason === 'length' ? 'length' :\n                    result.finishReason === 'tool-calls' ? 'tool_calls' :\n                    result.finishReason === 'content-filter' ? 'content_filter' : 'error',\n      usage: {\n        promptTokens: result.usage.promptTokens,\n        completionTokens: result.usage.completionTokens,\n        totalTokens: result.usage.totalTokens,\n      },\n      toolCalls,\n      rawResponse: result,\n    };\n  }\n\n  /**\n   * Generate text with streaming\n   */\n  async stream(options: GenerateOptions): Promise<StreamResult> {\n    const model = this.provider(\n      options.model || this.config.defaultModel || 'llama3.1',\n      {\n        simulateStreaming: true,\n        structuredOutputs: true,\n      }\n    );\n\n    // Convert tools if provided\n    const tools: Record<string, any> = {};\n    if (options.tools) {\n      for (const toolDef of options.tools) {\n        const params = toolDef.function.parameters;\n        tools[toolDef.function.name] = aiTool({\n          description: toolDef.function.description,\n          parameters: params as any,\n          execute: async () => {\n            // This is just a placeholder, actual execution happens in AgentExecutor\n            return null;\n          },\n        });\n      }\n    }\n\n    const result = await streamText({\n      model,\n      messages: convertMessages(options.messages) as any,\n      temperature: options.temperature,\n      maxTokens: options.maxTokens,\n      topP: options.topP,\n      frequencyPenalty: options.frequencyPenalty,\n      presencePenalty: options.presencePenalty,\n      seed: options.seed,\n      tools: Object.keys(tools).length > 0 ? tools : undefined,\n      maxSteps: 1, // Single step for streaming\n    });\n\n    // Create text stream\n    const textStream = (async function* () {\n      for await (const delta of result.textStream) {\n        yield delta;\n      }\n    })();\n\n    // Create full stream with all event types\n    const fullStream = (async function* () {\n      for await (const delta of result.textStream) {\n        const chunk: StreamChunk = {\n          type: 'text-delta',\n          textDelta: delta,\n        };\n        yield chunk;\n      }\n\n      // Wait for final result to get usage stats\n      const [finalText, finalUsage, finalReason] = await Promise.all([\n        result.text,\n        result.usage,\n        result.finishReason,\n      ]);\n\n      // Emit finish event\n      const chunk: StreamChunk = {\n        type: 'finish',\n        finishReason: finalReason,\n        usage: {\n          promptTokens: finalUsage.promptTokens,\n          completionTokens: finalUsage.completionTokens,\n          totalTokens: finalUsage.totalTokens,\n        },\n      };\n      yield chunk;\n    })();\n\n    // Return promises for final values\n    return {\n      textStream,\n      fullStream,\n      text: (async () => {\n        const finalText = await result.text;\n        return finalText;\n      })(),\n      usage: (async () => {\n        const finalUsage = await result.usage;\n        return {\n          promptTokens: finalUsage.promptTokens,\n          completionTokens: finalUsage.completionTokens,\n          totalTokens: finalUsage.totalTokens,\n        };\n      })(),\n      finishReason: (async () => {\n        const reason = await result.finishReason;\n        return reason;\n      })(),\n      toolCalls: (async () => {\n        const calls = await result.toolCalls;\n        return calls.map((tc: any) => ({\n          id: tc.toolCallId,\n          type: 'function' as const,\n          function: {\n            name: tc.toolName,\n            arguments: JSON.stringify(tc.args),\n          },\n        }));\n      })(),\n    };\n  }\n\n  /**\n   * Check if model supports tools\n   */\n  supportsTools(model: string): boolean {\n    // Newer Llama models support tools\n    return model.includes('llama3') || model.includes('mistral');\n  }\n\n  /**\n   * Check if model supports streaming\n   */\n  supportsStreaming(model: string): boolean {\n    return true; // All Ollama models support streaming\n  }\n\n  /**\n   * Get available models\n   */\n  async getModels(): Promise<string[]> {\n    try {\n      const response = await fetch(`${this.config.baseURL || 'http://localhost:11434'}/api/tags`);\n      const data = await response.json();\n      return data.models?.map((m: any) => m.name) || [];\n    } catch (error) {\n      console.warn('Failed to fetch Ollama models:', error);\n      return ['llama3.1', 'llama2', 'mistral'];\n    }\n  }\n}\n","/**\n * Providers Module\n * LLM provider abstraction and implementations\n */\n\nexport * from './llm';\nexport * from './mock';\nexport * from './OpenAIProvider';\nexport * from './OllamaProvider';\n\n// Auto-register built-in providers\nimport { LLMProviderRegistry } from './llm';\nimport { OpenAIProvider, OpenAIProviderConfig } from './OpenAIProvider';\nimport { OllamaProvider, OllamaProviderConfig } from './OllamaProvider';\n\nLLMProviderRegistry.register('openai', (config) => new OpenAIProvider(config as OpenAIProviderConfig));\nLLMProviderRegistry.register('ollama', (config) => new OllamaProvider(config as OllamaProviderConfig));\n","/**\n * Agent Executor\n * Executes agents with streaming support and tool calling\n */\n\nimport { LLMProvider, Message, ToolCall } from '../providers';\nimport { AgentConfig } from '../types';\nimport { ToolRegistry } from '../tools';\n\n/**\n * Execution event types\n */\nexport type ExecutionEventType =\n  | 'start'\n  | 'text-delta'\n  | 'text-complete'\n  | 'tool-call'\n  | 'tool-result'\n  | 'finish'\n  | 'error';\n\n/**\n * Execution event\n */\nexport interface ExecutionEvent {\n  type: ExecutionEventType;\n  timestamp: Date;\n  agentId?: string;\n  agentName?: string;\n  textDelta?: string;\n  text?: string;\n  toolCall?: ToolCall;\n  toolResult?: {\n    toolCallId: string;\n    toolName: string;\n    result: any;\n    error?: string;\n  };\n  finishReason?: string;\n  usage?: {\n    promptTokens: number;\n    completionTokens: number;\n    totalTokens: number;\n  };\n  error?: Error;\n}\n\n/**\n * Execution options\n */\nexport interface ExecuteOptions {\n  agent: AgentConfig;\n  input: string | Message[];\n  provider: LLMProvider;\n  toolRegistry?: ToolRegistry;\n  streaming?: boolean;\n  maxSteps?: number;\n  temperature?: number;\n  maxTokens?: number;\n  onEvent?: (event: ExecutionEvent) => void;\n}\n\n/**\n * Execution result\n */\nexport interface ExecutionResult {\n  text: string;\n  messages: Message[];\n  toolCalls: ToolCall[];\n  usage: {\n    promptTokens: number;\n    completionTokens: number;\n    totalTokens: number;\n  };\n  finishReason: string;\n  steps: number;\n}\n\n/**\n * Agent Executor\n */\nexport class AgentExecutor {\n  /**\n   * Execute agent without streaming\n   */\n  static async execute(options: ExecuteOptions): Promise<ExecutionResult> {\n    const {\n      agent,\n      input,\n      provider,\n      toolRegistry,\n      maxSteps = 10,\n      temperature,\n      maxTokens,\n      onEvent,\n    } = options;\n\n    // Emit start event\n    this.emitEvent(onEvent, {\n      type: 'start',\n      timestamp: new Date(),\n      agentId: agent.id,\n      agentName: agent.name,\n    });\n\n    // Build messages\n    const messages = this.buildMessages(agent, input);\n\n    // Build tools\n    const tools = this.buildTools(agent, toolRegistry);\n\n    let currentMessages = [...messages];\n    let allToolCalls: ToolCall[] = [];\n    let totalUsage = {\n      promptTokens: 0,\n      completionTokens: 0,\n      totalTokens: 0,\n    };\n    let steps = 0;\n    let finalText = '';\n    let finishReason = 'stop';\n\n    // Execution loop with tool calling\n    while (steps < maxSteps) {\n      steps++;\n\n      try {\n        const result = await provider.generate({\n          model: agent.settings?.model || 'gpt-4',\n          messages: currentMessages,\n          temperature,\n          maxTokens,\n          tools: tools.length > 0 ? tools : undefined,\n        });\n\n        // Update usage\n        totalUsage.promptTokens += result.usage.promptTokens;\n        totalUsage.completionTokens += result.usage.completionTokens;\n        totalUsage.totalTokens += result.usage.totalTokens;\n\n        // Handle text response\n        if (result.text) {\n          finalText = result.text;\n          this.emitEvent(onEvent, {\n            type: 'text-complete',\n            timestamp: new Date(),\n            text: result.text,\n          });\n        }\n\n        // Handle tool calls\n        if (result.toolCalls && result.toolCalls.length > 0) {\n          allToolCalls.push(...result.toolCalls);\n\n          // Add assistant message with tool calls\n          currentMessages.push({\n            role: 'assistant',\n            content: result.text || '',\n            toolCalls: result.toolCalls,\n          });\n\n          // Execute tools and add results\n          for (const toolCall of result.toolCalls) {\n            this.emitEvent(onEvent, {\n              type: 'tool-call',\n              timestamp: new Date(),\n              toolCall,\n            });\n\n            const toolResult = await this.executeToolCall(\n              toolCall,\n              agent,\n              toolRegistry\n            );\n\n            this.emitEvent(onEvent, {\n              type: 'tool-result',\n              timestamp: new Date(),\n              toolResult,\n            });\n\n            currentMessages.push({\n              role: 'tool',\n              content: JSON.stringify(toolResult.result),\n              name: toolCall.function.name,\n              toolCallId: toolCall.id,\n            });\n          }\n\n          // Continue loop for next generation\n          finishReason = result.finishReason;\n          continue;\n        }\n\n        // No tool calls, we're done\n        finishReason = result.finishReason;\n        break;\n      } catch (error) {\n        this.emitEvent(onEvent, {\n          type: 'error',\n          timestamp: new Date(),\n          error: error as Error,\n        });\n        throw error;\n      }\n    }\n\n    // Emit finish event\n    this.emitEvent(onEvent, {\n      type: 'finish',\n      timestamp: new Date(),\n      finishReason,\n      usage: totalUsage,\n    });\n\n    return {\n      text: finalText,\n      messages: currentMessages,\n      toolCalls: allToolCalls,\n      usage: totalUsage,\n      finishReason,\n      steps,\n    };\n  }\n\n  /**\n   * Build messages from input\n   */\n  private static buildMessages(\n    agent: AgentConfig,\n    input: string | Message[]\n  ): Message[] {\n    const messages: Message[] = [];\n\n    // Add system prompt\n    if (agent.prompt) {\n      messages.push({\n        role: 'system',\n        content: agent.prompt,\n      });\n    }\n\n    // Add input messages\n    if (typeof input === 'string') {\n      messages.push({\n        role: 'user',\n        content: input,\n      });\n    } else {\n      messages.push(...input);\n    }\n\n    return messages;\n  }\n\n  /**\n   * Build tools from agent and registry\n   */\n  private static buildTools(\n    agent: AgentConfig,\n    toolRegistry?: ToolRegistry\n  ): any[] {\n    if (!agent.tools || !toolRegistry) {\n      return [];\n    }\n\n    const tools: any[] = [];\n\n    for (const [toolName, toolConfig] of Object.entries(agent.tools)) {\n      const toolDesc = toolRegistry.get(toolName);\n      if (toolDesc && toolDesc.tool) {\n        // The tool from 'ai' SDK already has description and parameters\n        tools.push({\n          type: 'function',\n          function: {\n            name: toolName,\n            description: toolDesc.tool.description || toolConfig.description || '',\n            parameters: toolDesc.tool.parameters || {},\n          },\n        });\n      }\n    }\n\n    return tools;\n  }\n\n  /**\n   * Execute a tool call\n   */\n  private static async executeToolCall(\n    toolCall: ToolCall,\n    agent: AgentConfig,\n    toolRegistry?: ToolRegistry\n  ): Promise<{\n    toolCallId: string;\n    toolName: string;\n    result: any;\n    error?: string;\n  }> {\n    if (!toolRegistry) {\n      return {\n        toolCallId: toolCall.id,\n        toolName: toolCall.function.name,\n        result: null,\n        error: 'No tool registry available',\n      };\n    }\n\n    try {\n      const toolDesc = toolRegistry.get(toolCall.function.name);\n      if (!toolDesc || !toolDesc.tool || !toolDesc.tool.execute) {\n        return {\n          toolCallId: toolCall.id,\n          toolName: toolCall.function.name,\n          result: null,\n          error: `Tool '${toolCall.function.name}' not found`,\n        };\n      }\n\n      const args = JSON.parse(toolCall.function.arguments);\n      // The 'ai' SDK tool.execute expects (args, context)\n      const result = await toolDesc.tool.execute(args, {} as any);\n\n      return {\n        toolCallId: toolCall.id,\n        toolName: toolCall.function.name,\n        result,\n      };\n    } catch (error) {\n      return {\n        toolCallId: toolCall.id,\n        toolName: toolCall.function.name,\n        result: null,\n        error: (error as Error).message,\n      };\n    }\n  }\n\n  /**\n   * Emit event to callback\n   */\n  private static emitEvent(\n    callback: ((event: ExecutionEvent) => void) | undefined,\n    event: ExecutionEvent\n  ): void {\n    if (callback) {\n      callback(event);\n    }\n  }\n}\n","/**\n * Memory Manager\n * Manages agent memories with relevance-based recall\n */\n\nimport { Memory, MemoryRepository } from '../data';\nimport { nanoid } from 'nanoid';\n\n/**\n * Memory manager configuration\n */\nexport interface MemoryManagerConfig {\n  repository: MemoryRepository;\n  maxMemories?: number;\n  relevanceThreshold?: number;\n}\n\n/**\n * Store memory options\n */\nexport interface StoreMemoryOptions {\n  agentId: string;\n  content: string;\n  metadata?: Record<string, any>;\n  embedding?: number[];\n  importance?: number;\n}\n\n/**\n * Recall memory options\n */\nexport interface RecallMemoryOptions {\n  agentId: string;\n  query?: string;\n  embedding?: number[];\n  limit?: number;\n  minRelevance?: number;\n}\n\n/**\n * Memory search result\n */\nexport interface MemorySearchResult {\n  memory: Memory;\n  relevance: number;\n}\n\n/**\n * Memory Manager\n * \n * Manages agent memories with relevance-based recall and vector similarity search.\n * \n * @example\n * ```typescript\n * const manager = new MemoryManager({\n *   repository: mockRepository,\n *   maxMemories: 100,\n * });\n * \n * // Store a memory\n * await manager.store({\n *   agentId: 'agent-1',\n *   content: 'User prefers dark mode',\n *   metadata: { category: 'preference' },\n * });\n * \n * // Recall relevant memories\n * const memories = await manager.recall({\n *   agentId: 'agent-1',\n *   query: 'user preferences',\n *   limit: 5,\n * });\n * ```\n */\nexport class MemoryManager {\n  private config: Required<MemoryManagerConfig>;\n\n  constructor(config: MemoryManagerConfig) {\n    this.config = {\n      repository: config.repository,\n      maxMemories: config.maxMemories ?? 1000,\n      relevanceThreshold: config.relevanceThreshold ?? 0.5,\n    };\n  }\n\n  /**\n   * Store a new memory\n   */\n  async store(options: StoreMemoryOptions): Promise<Memory> {\n    const { agentId, content, metadata, embedding, importance = 1 } = options;\n\n    // Check if we need to prune old memories\n    await this.pruneMemoriesIfNeeded(agentId);\n\n    // Create memory with extended metadata\n    const extendedMetadata = {\n      ...metadata,\n      importance,\n      accessCount: 0,\n      accessedAt: new Date().toISOString(),\n    };\n\n    const memory = new Memory({\n      id: nanoid(),\n      agentId,\n      content,\n      embedding: embedding ?? [],\n      metadata: extendedMetadata,\n      createdAt: new Date().toISOString(),\n    });\n\n    // Store in repository\n    return await this.config.repository.create(memory);\n  }\n\n  /**\n   * Recall relevant memories\n   */\n  async recall(options: RecallMemoryOptions): Promise<MemorySearchResult[]> {\n    const {\n      agentId,\n      query,\n      embedding,\n      limit = 10,\n      minRelevance = this.config.relevanceThreshold,\n    } = options;\n\n    let memories: Memory[];\n\n    // Use embedding search if available\n    if (embedding && embedding.length > 0) {\n      memories = await this.config.repository.searchByEmbedding(\n        agentId,\n        embedding,\n        limit * 2 // Get more to filter by relevance\n      );\n    } else {\n      // Fallback to getting recent memories\n      memories = await this.config.repository.findByAgentId(agentId, limit * 2);\n    }\n\n    // Calculate relevance scores\n    const results = memories.map((memory) => ({\n      memory,\n      relevance: this.calculateRelevance(memory, { query, embedding }),\n    }));\n\n    // Filter by minimum relevance and sort\n    const filtered = results\n      .filter((r) => r.relevance >= minRelevance)\n      .sort((a, b) => b.relevance - a.relevance)\n      .slice(0, limit);\n\n    // Update access stats\n    await Promise.all(\n      filtered.map((r) =>\n        this.updateAccessStats(r.memory.id!)\n      )\n    );\n\n    return filtered;\n  }\n\n  /**\n   * Search memories by embedding (vector similarity)\n   */\n  async searchByEmbedding(\n    agentId: string,\n    embedding: number[],\n    limit: number = 10\n  ): Promise<MemorySearchResult[]> {\n    const memories = await this.config.repository.searchByEmbedding(\n      agentId,\n      embedding,\n      limit\n    );\n\n    return memories.map((memory) => ({\n      memory,\n      relevance: this.calculateEmbeddingSimilarity(embedding, memory.embedding || []),\n    }));\n  }\n\n  /**\n   * Get memory by ID\n   */\n  async getById(id: string): Promise<Memory | null> {\n    return await this.config.repository.findById(id);\n  }\n\n  /**\n   * Update memory\n   */\n  async update(id: string, updates: Partial<Memory>): Promise<Memory> {\n    return await this.config.repository.update(id, updates);\n  }\n\n  /**\n   * Delete memory\n   */\n  async delete(id: string): Promise<void> {\n    await this.config.repository.delete(id);\n  }\n\n  /**\n   * Delete all memories for an agent\n   */\n  async deleteAllForAgent(agentId: string): Promise<void> {\n    const memories = await this.config.repository.findByAgentId(agentId, 1000);\n    \n    await Promise.all(\n      memories.map((memory) => this.config.repository.delete(memory.id!))\n    );\n  }\n\n  /**\n   * Get memory statistics for an agent\n   */\n  async getStats(agentId: string): Promise<{\n    total: number;\n    avgImportance: number;\n    avgAccessCount: number;\n    oldestMemory: string | null;\n    newestMemory: string | null;\n  }> {\n    const memories = await this.config.repository.findByAgentId(agentId, 1000);\n\n    if (memories.length === 0) {\n      return {\n        total: 0,\n        avgImportance: 0,\n        avgAccessCount: 0,\n        oldestMemory: null,\n        newestMemory: null,\n      };\n    }\n\n    // Extract metadata\n    const importances = memories.map((m) => m.metadata?.importance || 1);\n    const accessCounts = memories.map((m) => m.metadata?.accessCount || 0);\n    \n    const avgImportance =\n      importances.reduce((sum: number, val: number) => sum + val, 0) / memories.length;\n    const avgAccessCount =\n      accessCounts.reduce((sum: number, val: number) => sum + val, 0) / memories.length;\n    const sortedByDate = [...memories].sort(\n      (a, b) => new Date(a.createdAt).getTime() - new Date(b.createdAt).getTime()\n    );\n\n    return {\n      total: memories.length,\n      avgImportance,\n      avgAccessCount,\n      oldestMemory: sortedByDate[0].createdAt,\n      newestMemory: sortedByDate[sortedByDate.length - 1].createdAt,\n    };\n  }\n\n  /**\n   * Calculate relevance score for a memory\n   */\n  private calculateRelevance(\n    memory: Memory,\n    context: { query?: string; embedding?: number[] }\n  ): number {\n    let score = 0;\n\n    const importance = memory.metadata?.importance || 1;\n    const accessCount = memory.metadata?.accessCount || 0;\n\n    // Base score from importance\n    score += importance * 0.3;\n\n    // Recency bonus (newer memories are more relevant)\n    const createdAt = new Date(memory.createdAt).getTime();\n    const ageInDays = (Date.now() - createdAt) / (1000 * 60 * 60 * 24);\n    const recencyScore = Math.max(0, 1 - ageInDays / 30); // Decay over 30 days\n    score += recencyScore * 0.2;\n\n    // Access frequency bonus\n    const accessScore = Math.min(1, accessCount / 10);\n    score += accessScore * 0.1;\n\n    // Embedding similarity\n    if (context.embedding && memory.embedding && memory.embedding.length > 0) {\n      const similarity = this.calculateEmbeddingSimilarity(\n        context.embedding,\n        memory.embedding\n      );\n      score += similarity * 0.4;\n    }\n\n    // Text similarity (simple keyword matching)\n    if (context.query) {\n      const textSimilarity = this.calculateTextSimilarity(\n        context.query,\n        memory.content\n      );\n      score += textSimilarity * 0.4;\n    }\n\n    return Math.min(1, score);\n  }\n\n  /**\n   * Calculate cosine similarity between two embeddings\n   */\n  private calculateEmbeddingSimilarity(\n    embedding1: number[],\n    embedding2: number[]\n  ): number {\n    if (embedding1.length === 0 || embedding2.length === 0) {\n      return 0;\n    }\n\n    if (embedding1.length !== embedding2.length) {\n      return 0;\n    }\n\n    let dotProduct = 0;\n    let magnitude1 = 0;\n    let magnitude2 = 0;\n\n    for (let i = 0; i < embedding1.length; i++) {\n      dotProduct += embedding1[i] * embedding2[i];\n      magnitude1 += embedding1[i] * embedding1[i];\n      magnitude2 += embedding2[i] * embedding2[i];\n    }\n\n    magnitude1 = Math.sqrt(magnitude1);\n    magnitude2 = Math.sqrt(magnitude2);\n\n    if (magnitude1 === 0 || magnitude2 === 0) {\n      return 0;\n    }\n\n    return dotProduct / (magnitude1 * magnitude2);\n  }\n\n  /**\n   * Calculate text similarity (simple keyword matching)\n   */\n  private calculateTextSimilarity(query: string, content: string): number {\n    const queryWords = query.toLowerCase().split(/\\s+/);\n    const contentWords = content.toLowerCase().split(/\\s+/);\n    const contentSet = new Set(contentWords);\n\n    const matchingWords = queryWords.filter((word) => contentSet.has(word));\n    \n    if (queryWords.length === 0) {\n      return 0;\n    }\n\n    return matchingWords.length / queryWords.length;\n  }\n\n  /**\n   * Update access statistics for a memory\n   */\n  private async updateAccessStats(memoryId: string): Promise<void> {\n    const memory = await this.config.repository.findById(memoryId);\n    \n    if (memory) {\n      const currentAccessCount = memory.metadata?.accessCount || 0;\n      const updatedMetadata = {\n        ...memory.metadata,\n        accessedAt: new Date().toISOString(),\n        accessCount: currentAccessCount + 1,\n      };\n      \n      await this.config.repository.update(memoryId, {\n        metadata: updatedMetadata,\n      });\n    }\n  }\n\n  /**\n   * Prune old memories if limit is exceeded\n   */\n  private async pruneMemoriesIfNeeded(agentId: string): Promise<void> {\n    const stats = await this.getStats(agentId);\n\n    if (stats.total >= this.config.maxMemories) {\n      // Get all memories for this agent\n      const memories = await this.config.repository.findByAgentId(agentId, 1000);\n\n      // Sort by relevance (importance, recency, access count)\n      const sorted = [...memories].sort((a, b) => {\n        const importanceA = a.metadata?.importance || 1;\n        const importanceB = b.metadata?.importance || 1;\n        const accessCountA = a.metadata?.accessCount || 0;\n        const accessCountB = b.metadata?.accessCount || 0;\n        const ageA = Date.now() - new Date(a.createdAt).getTime();\n        const ageB = Date.now() - new Date(b.createdAt).getTime();\n        \n        const scoreA = importanceA * 0.5 + \n                      (accessCountA / 10) * 0.3 + \n                      (1 - ageA / (1000 * 60 * 60 * 24 * 30)) * 0.2;\n        const scoreB = importanceB * 0.5 + \n                      (accessCountB / 10) * 0.3 + \n                      (1 - ageB / (1000 * 60 * 60 * 24 * 30)) * 0.2;\n        return scoreA - scoreB; // Sort ascending (least relevant first)\n      });\n\n      // Delete least relevant memories\n      const toDelete = Math.ceil(this.config.maxMemories * 0.1); // Delete 10% of limit\n      const memoriesToDelete = sorted.slice(0, toDelete);\n\n      await Promise.all(\n        memoriesToDelete.map((memory) =>\n          this.config.repository.delete(memory.id!)\n        )\n      );\n    }\n  }\n}\n","/**\n * Context Builder\n * Builds execution context for agent runs\n */\n\nimport { AgentConfig } from '../types';\nimport { Message } from '../providers';\nimport { Memory } from '../data';\nimport { MemoryManager } from './MemoryManager';\n\n/**\n * Context builder options\n */\nexport interface ContextBuilderOptions {\n  agent: AgentConfig;\n  input: string | Message[];\n  sessionHistory?: Message[];\n  memoryManager?: MemoryManager;\n  variables?: Record<string, any>;\n  systemPrompt?: string;\n  maxHistoryMessages?: number;\n  maxMemories?: number;\n}\n\n/**\n * Built context\n */\nexport interface ExecutionContext {\n  messages: Message[];\n  variables: Record<string, any>;\n  systemPrompt: string;\n  metadata: {\n    agentId: string;\n    agentName: string;\n    agentType: string;\n    hasMemories: boolean;\n    memoryCount: number;\n    historyCount: number;\n  };\n}\n\n/**\n * Context Builder\n * \n * Builds execution context from agent config, input, session history, and memories.\n * \n * @example\n * ```typescript\n * const context = await ContextBuilder.build({\n *   agent: myAgent,\n *   input: 'Hello!',\n *   sessionHistory: previousMessages,\n *   memoryManager,\n *   variables: { userName: 'Alice' },\n * });\n * \n * // Use context in execution\n * const result = await provider.generate({\n *   messages: context.messages,\n *   temperature: 0.7,\n * });\n * ```\n */\nexport class ContextBuilder {\n  /**\n   * Build execution context\n   */\n  static async build(\n    options: ContextBuilderOptions\n  ): Promise<ExecutionContext> {\n    const {\n      agent,\n      input,\n      sessionHistory = [],\n      memoryManager,\n      variables = {},\n      systemPrompt,\n      maxHistoryMessages = 20,\n      maxMemories = 5,\n    } = options;\n\n    // 1. Build system prompt\n    let finalSystemPrompt = await this.buildSystemPrompt({\n      agent,\n      systemPrompt,\n      memoryManager,\n      maxMemories,\n    });\n\n    // 2. Inject variables into system prompt\n    finalSystemPrompt = this.interpolateVariables(finalSystemPrompt, variables);\n\n    // 3. Build message array\n    const messages = await this.buildMessages({\n      systemPrompt: finalSystemPrompt,\n      input,\n      sessionHistory,\n      maxHistoryMessages,\n    });\n\n    // 4. Inject variables into messages\n    const processedMessages = this.injectVariables(messages, variables);\n\n    // 5. Build metadata\n    const metadata = {\n      agentId: agent.id || '',\n      agentName: agent.name,\n      agentType: agent.agentType as string,\n      hasMemories: !!memoryManager,\n      memoryCount: 0, // Will be updated if memories are recalled\n      historyCount: sessionHistory.length,\n    };\n\n    return {\n      messages: processedMessages,\n      variables,\n      systemPrompt: finalSystemPrompt,\n      metadata,\n    };\n  }\n\n  /**\n   * Build system prompt with agent instructions and memories\n   */\n  private static async buildSystemPrompt(options: {\n    agent: AgentConfig;\n    systemPrompt?: string;\n    memoryManager?: MemoryManager;\n    maxMemories: number;\n  }): Promise<string> {\n    const { agent, systemPrompt, memoryManager, maxMemories } = options;\n\n    const parts: string[] = [];\n\n    // Add agent name and role first\n    if (agent.name) {\n      parts.push(`You are ${agent.name}.`);\n    }\n\n    // Add agent metadata description if available\n    if (agent.metadata?.description) {\n      parts.push(agent.metadata.description);\n    }\n\n    // Add custom system prompt or agent prompt\n    const prompt = systemPrompt || agent.prompt || '';\n    if (prompt) {\n      parts.push(prompt);\n    }\n\n    // Recall and inject relevant memories\n    if (memoryManager && agent.id) {\n      const memories = await memoryManager.recall({\n        agentId: agent.id,\n        limit: maxMemories,\n        minRelevance: 0.3, // Lower threshold for when no query/embedding provided\n      });\n\n      if (memories.length > 0) {\n        const memoryText = memories\n          .map((m, i) => `${i + 1}. ${m.memory.content}`)\n          .join('\\n');\n\n        parts.push(`## Relevant Memories\\n${memoryText}`);\n      }\n    }\n\n    return parts.filter(p => p).join('\\n\\n').trim();\n  }\n\n  /**\n   * Build message array from input and history\n   */\n  private static async buildMessages(options: {\n    systemPrompt: string;\n    input: string | Message[];\n    sessionHistory: Message[];\n    maxHistoryMessages: number;\n  }): Promise<Message[]> {\n    const { systemPrompt, input, sessionHistory, maxHistoryMessages } = options;\n\n    const messages: Message[] = [];\n\n    // Add system message\n    if (systemPrompt) {\n      messages.push({\n        role: 'system',\n        content: systemPrompt,\n      });\n    }\n\n    // Add session history (limited)\n    const limitedHistory = sessionHistory.slice(-maxHistoryMessages);\n    messages.push(...limitedHistory);\n\n    // Add current input\n    if (typeof input === 'string') {\n      messages.push({\n        role: 'user',\n        content: input,\n      });\n    } else {\n      messages.push(...input);\n    }\n\n    return messages;\n  }\n\n  /**\n   * Inject variables into messages\n   */\n  private static injectVariables(\n    messages: Message[],\n    variables: Record<string, any>\n  ): Message[] {\n    if (Object.keys(variables).length === 0) {\n      return messages;\n    }\n\n    return messages.map((message) => {\n      if (typeof message.content === 'string') {\n        return {\n          ...message,\n          content: this.interpolateVariables(message.content, variables),\n        };\n      }\n      return message;\n    });\n  }\n\n  /**\n   * Interpolate variables in text ({{variable}} syntax)\n   */\n  private static interpolateVariables(\n    text: string,\n    variables: Record<string, any>\n  ): string {\n    return text.replace(/\\{\\{(\\w+)\\}\\}/g, (match, varName) => {\n      const value = variables[varName];\n      if (value === undefined) {\n        return match; // Keep original if variable not found\n      }\n      return String(value);\n    });\n  }\n\n  /**\n   * Merge multiple contexts (useful for multi-agent scenarios)\n   */\n  static merge(...contexts: ExecutionContext[]): ExecutionContext {\n    if (contexts.length === 0) {\n      throw new Error('At least one context is required');\n    }\n\n    if (contexts.length === 1) {\n      return contexts[0];\n    }\n\n    const merged: ExecutionContext = {\n      messages: [],\n      variables: {},\n      systemPrompt: '',\n      metadata: {\n        agentId: contexts[0].metadata.agentId,\n        agentName: contexts[0].metadata.agentName,\n        agentType: contexts[0].metadata.agentType,\n        hasMemories: false,\n        memoryCount: 0,\n        historyCount: 0,\n      },\n    };\n\n    // Merge messages (deduplicate system messages)\n    const systemMessages: Message[] = [];\n    const otherMessages: Message[] = [];\n\n    for (const context of contexts) {\n      for (const message of context.messages) {\n        if (message.role === 'system') {\n          // Only add unique system messages\n          if (\n            !systemMessages.some((m) => m.content === message.content)\n          ) {\n            systemMessages.push(message);\n          }\n        } else {\n          otherMessages.push(message);\n        }\n      }\n    }\n\n    merged.messages = [...systemMessages, ...otherMessages];\n\n    // Merge variables (later contexts override earlier ones)\n    for (const context of contexts) {\n      merged.variables = { ...merged.variables, ...context.variables };\n    }\n\n    // Merge system prompts\n    merged.systemPrompt = contexts\n      .map((c) => c.systemPrompt)\n      .filter((p) => p)\n      .join('\\n\\n---\\n\\n');\n\n    // Merge metadata\n    merged.metadata.hasMemories = contexts.some((c) => c.metadata.hasMemories);\n    merged.metadata.memoryCount = contexts.reduce(\n      (sum, c) => sum + c.metadata.memoryCount,\n      0\n    );\n    merged.metadata.historyCount = contexts.reduce(\n      (sum, c) => sum + c.metadata.historyCount,\n      0\n    );\n\n    return merged;\n  }\n\n  /**\n   * Clone context with modifications\n   */\n  static clone(\n    context: ExecutionContext,\n    modifications?: Partial<ExecutionContext>\n  ): ExecutionContext {\n    return {\n      messages: modifications?.messages || [...context.messages],\n      variables: modifications?.variables || { ...context.variables },\n      systemPrompt: modifications?.systemPrompt || context.systemPrompt,\n      metadata: modifications?.metadata || { ...context.metadata },\n    };\n  }\n\n  /**\n   * Extract variables from context messages\n   */\n  static extractVariables(context: ExecutionContext): string[] {\n    const variables = new Set<string>();\n    const regex = /\\{\\{(\\w+)\\}\\}/g;\n\n    for (const message of context.messages) {\n      if (typeof message.content === 'string') {\n        let match;\n        while ((match = regex.exec(message.content)) !== null) {\n          variables.add(match[1]);\n        }\n      }\n    }\n\n    return Array.from(variables);\n  }\n\n  /**\n   * Validate context has all required variables\n   */\n  static validate(context: ExecutionContext): {\n    valid: boolean;\n    missingVariables: string[];\n  } {\n    const requiredVariables = this.extractVariables(context);\n    const missingVariables = requiredVariables.filter(\n      (varName) => context.variables[varName] === undefined\n    );\n\n    return {\n      valid: missingVariables.length === 0,\n      missingVariables,\n    };\n  }\n}\n","/**\n * Error Classes\n * Custom error types for SDK operations\n */\n\n/**\n * Base SDK error\n */\nexport class SDKError extends Error {\n  constructor(message: string, public readonly code?: string) {\n    super(message);\n    this.name = 'SDKError';\n  }\n}\n\n/**\n * Agent execution error\n */\nexport class AgentExecutionError extends SDKError {\n  constructor(\n    message: string,\n    public readonly agentId?: string,\n    public readonly cause?: Error\n  ) {\n    super(message, 'AGENT_EXECUTION_ERROR');\n    this.name = 'AgentExecutionError';\n  }\n}\n\n/**\n * Tool execution error\n */\nexport class ToolExecutionError extends SDKError {\n  constructor(\n    message: string,\n    public readonly toolName?: string,\n    public readonly cause?: Error\n  ) {\n    super(message, 'TOOL_EXECUTION_ERROR');\n    this.name = 'ToolExecutionError';\n  }\n}\n\n/**\n * LLM provider error\n */\nexport class LLMProviderError extends SDKError {\n  constructor(\n    message: string,\n    public readonly providerName?: string,\n    public readonly statusCode?: number,\n    public readonly cause?: Error\n  ) {\n    super(message, 'LLM_PROVIDER_ERROR');\n    this.name = 'LLMProviderError';\n  }\n}\n\n/**\n * Flow execution error\n */\nexport class FlowExecutionError extends SDKError {\n  constructor(\n    message: string,\n    public readonly flowCode?: string,\n    public readonly step?: string,\n    public readonly cause?: Error\n  ) {\n    super(message, 'FLOW_EXECUTION_ERROR');\n    this.name = 'FlowExecutionError';\n  }\n}\n\n/**\n * Configuration error\n */\nexport class ConfigurationError extends SDKError {\n  constructor(message: string, public readonly field?: string) {\n    super(message, 'CONFIGURATION_ERROR');\n    this.name = 'ConfigurationError';\n  }\n}\n\n/**\n * Validation error\n */\nexport class ValidationError extends SDKError {\n  constructor(\n    message: string,\n    public readonly errors?: Record<string, string[]>\n  ) {\n    super(message, 'VALIDATION_ERROR');\n    this.name = 'ValidationError';\n  }\n}\n\n/**\n * Timeout error\n */\nexport class TimeoutError extends SDKError {\n  constructor(\n    message: string,\n    public readonly timeoutMs?: number,\n    public readonly operation?: string\n  ) {\n    super(message, 'TIMEOUT_ERROR');\n    this.name = 'TimeoutError';\n  }\n}\n\n/**\n * Rate limit error\n */\nexport class RateLimitError extends SDKError {\n  constructor(\n    message: string,\n    public readonly retryAfter?: number,\n    public readonly limit?: number\n  ) {\n    super(message, 'RATE_LIMIT_ERROR');\n    this.name = 'RateLimitError';\n  }\n}\n\n/**\n * Check if error is retryable\n */\nexport function isRetryableError(error: Error): boolean {\n  if (error instanceof RateLimitError) {\n    return true;\n  }\n\n  if (error instanceof LLMProviderError) {\n    // Retry on 5xx errors and some 4xx errors\n    if (error.statusCode) {\n      return (\n        error.statusCode >= 500 ||\n        error.statusCode === 408 || // Request Timeout\n        error.statusCode === 429 // Too Many Requests\n      );\n    }\n    return true;\n  }\n\n  if (error instanceof TimeoutError) {\n    return true;\n  }\n\n  return false;\n}\n\n/**\n * Check if error is a network error\n */\nexport function isNetworkError(error: Error): boolean {\n  const networkErrorMessages = [\n    'econnrefused',\n    'enotfound',\n    'etimedout',\n    'econnreset',\n    'network',\n    'fetch failed',\n  ];\n\n  const message = error.message.toLowerCase();\n  return networkErrorMessages.some((msg) => message.includes(msg.toLowerCase()));\n}\n\n/**\n * Extract retry delay from error (for rate limiting)\n */\nexport function getRetryDelay(error: Error): number | undefined {\n  if (error instanceof RateLimitError && error.retryAfter) {\n    return error.retryAfter * 1000; // Convert to ms\n  }\n\n  if (error instanceof LLMProviderError) {\n    // Some providers send retry-after in seconds\n    if (error.statusCode === 429) {\n      return 60000; // Default 1 minute for rate limits\n    }\n  }\n\n  return undefined;\n}\n","/**\n * Retry Logic\n * Exponential backoff and retry utilities\n */\n\nimport { isRetryableError, getRetryDelay, TimeoutError } from './errors';\n\n/**\n * Retry options\n */\nexport interface RetryOptions {\n  maxAttempts?: number;\n  initialDelayMs?: number;\n  maxDelayMs?: number;\n  backoffMultiplier?: number;\n  timeout?: number;\n  onRetry?: (error: Error, attempt: number, delayMs: number) => void;\n  shouldRetry?: (error: Error, attempt: number) => boolean;\n}\n\n/**\n * Retry result\n */\nexport interface RetryResult<T> {\n  value: T;\n  attempts: number;\n  totalDelayMs: number;\n}\n\n/**\n * Retry an async operation with exponential backoff\n * \n * @example\n * ```typescript\n * const result = await retry(\n *   async () => {\n *     return await provider.generate({ messages });\n *   },\n *   {\n *     maxAttempts: 3,\n *     initialDelayMs: 1000,\n *     onRetry: (error, attempt, delay) => {\n *       console.log(`Retry attempt ${attempt} after ${delay}ms: ${error.message}`);\n *     },\n *   }\n * );\n * ```\n */\nexport async function retry<T>(\n  operation: () => Promise<T>,\n  options: RetryOptions = {}\n): Promise<RetryResult<T>> {\n  const {\n    maxAttempts = 3,\n    initialDelayMs = 1000,\n    maxDelayMs = 60000,\n    backoffMultiplier = 2,\n    timeout,\n    onRetry,\n    shouldRetry = isRetryableError,\n  } = options;\n\n  let attempt = 0;\n  let totalDelayMs = 0;\n  let lastError: Error | undefined;\n\n  while (attempt < maxAttempts) {\n    attempt++;\n\n    try {\n      // Apply timeout if specified\n      const value = timeout\n        ? await withTimeout(operation(), timeout)\n        : await operation();\n\n      return {\n        value,\n        attempts: attempt,\n        totalDelayMs,\n      };\n    } catch (error) {\n      lastError = error as Error;\n\n      // Don't retry if it's the last attempt\n      if (attempt >= maxAttempts) {\n        break;\n      }\n\n      // Check if error is retryable\n      if (!shouldRetry(lastError, attempt)) {\n        break;\n      }\n\n      // Calculate delay\n      let delayMs = getRetryDelay(lastError);\n      \n      if (delayMs === undefined) {\n        // Use exponential backoff\n        delayMs = Math.min(\n          initialDelayMs * Math.pow(backoffMultiplier, attempt - 1),\n          maxDelayMs\n        );\n\n        // Add jitter (20%)\n        const jitter = delayMs * 0.2 * (Math.random() - 0.5);\n        delayMs = Math.round(delayMs + jitter);\n        \n        // Ensure delay doesn't exceed maxDelayMs after jitter\n        delayMs = Math.min(delayMs, maxDelayMs);\n      }\n\n      totalDelayMs += delayMs;\n\n      // Call onRetry callback\n      if (onRetry) {\n        onRetry(lastError, attempt, delayMs);\n      }\n\n      // Wait before retrying\n      await sleep(delayMs);\n    }\n  }\n\n  // All attempts failed\n  throw lastError;\n}\n\n/**\n * Retry with specific error types\n */\nexport async function retryOnError<T>(\n  operation: () => Promise<T>,\n  errorTypes: (new (...args: any[]) => Error)[],\n  options: RetryOptions = {}\n): Promise<RetryResult<T>> {\n  return retry(operation, {\n    ...options,\n    shouldRetry: (error, attempt) => {\n      // Check if error matches any of the specified types\n      const isMatchingError = errorTypes.some(\n        (ErrorType) => error instanceof ErrorType\n      );\n\n      if (!isMatchingError) {\n        return false;\n      }\n\n      // Also check the default retry logic\n      if (options.shouldRetry) {\n        return options.shouldRetry(error, attempt);\n      }\n\n      return isRetryableError(error);\n    },\n  });\n}\n\n/**\n * Retry with timeout for each attempt\n */\nexport async function retryWithTimeout<T>(\n  operation: () => Promise<T>,\n  timeoutMs: number,\n  options: RetryOptions = {}\n): Promise<RetryResult<T>> {\n  return retry(operation, {\n    ...options,\n    timeout: timeoutMs,\n  });\n}\n\n/**\n * Batch retry multiple operations\n */\nexport async function retryBatch<T>(\n  operations: Array<() => Promise<T>>,\n  options: RetryOptions = {}\n): Promise<Array<RetryResult<T>>> {\n  return Promise.all(operations.map((op) => retry(op, options)));\n}\n\n/**\n * Retry with exponential backoff and circuit breaker\n */\nexport class RetryableOperation<T> {\n  private failureCount = 0;\n  private lastFailureTime: number | null = null;\n  private circuitBreakerThreshold: number;\n  private circuitBreakerResetMs: number;\n\n  constructor(\n    private operation: () => Promise<T>,\n    private options: RetryOptions & {\n      circuitBreakerThreshold?: number;\n      circuitBreakerResetMs?: number;\n    } = {}\n  ) {\n    this.circuitBreakerThreshold =\n      options.circuitBreakerThreshold ?? 5;\n    this.circuitBreakerResetMs =\n      options.circuitBreakerResetMs ?? 60000;\n  }\n\n  async execute(): Promise<RetryResult<T>> {\n    // Check circuit breaker\n    if (this.isCircuitOpen()) {\n      throw new Error(\n        `Circuit breaker is open. Too many failures (${this.failureCount}). Try again later.`\n      );\n    }\n\n    try {\n      const result = await retry(this.operation, this.options);\n      \n      // Reset failure count on success\n      this.failureCount = 0;\n      this.lastFailureTime = null;\n\n      return result;\n    } catch (error) {\n      this.recordFailure();\n      throw error;\n    }\n  }\n\n  private isCircuitOpen(): boolean {\n    if (this.failureCount < this.circuitBreakerThreshold) {\n      return false;\n    }\n\n    if (!this.lastFailureTime) {\n      return false;\n    }\n\n    // Check if enough time has passed to try again\n    const timeSinceLastFailure = Date.now() - this.lastFailureTime;\n    if (timeSinceLastFailure >= this.circuitBreakerResetMs) {\n      // Reset the circuit\n      this.failureCount = 0;\n      this.lastFailureTime = null;\n      return false;\n    }\n\n    return true;\n  }\n\n  private recordFailure(): void {\n    this.failureCount++;\n    this.lastFailureTime = Date.now();\n  }\n\n  reset(): void {\n    this.failureCount = 0;\n    this.lastFailureTime = null;\n  }\n\n  getStatus(): {\n    isOpen: boolean;\n    failureCount: number;\n    lastFailureTime: number | null;\n  } {\n    return {\n      isOpen: this.isCircuitOpen(),\n      failureCount: this.failureCount,\n      lastFailureTime: this.lastFailureTime,\n    };\n  }\n}\n\n/**\n * Sleep for specified milliseconds\n */\nfunction sleep(ms: number): Promise<void> {\n  return new Promise((resolve) => setTimeout(resolve, ms));\n}\n\n/**\n * Wrap operation with timeout\n */\nfunction withTimeout<T>(\n  promise: Promise<T>,\n  timeoutMs: number\n): Promise<T> {\n  return new Promise((resolve, reject) => {\n    const timer = setTimeout(() => {\n      reject(\n        new TimeoutError(\n          `Operation timed out after ${timeoutMs}ms`,\n          timeoutMs\n        )\n      );\n    }, timeoutMs);\n\n    promise\n      .then((value) => {\n        clearTimeout(timer);\n        resolve(value);\n      })\n      .catch((error) => {\n        clearTimeout(timer);\n        reject(error);\n      });\n  });\n}\n","/**\n * Cryptographic utilities for encryption, decryption, and hashing\n */\n\nimport { DTOEncryptionSettings } from './types';\n\n/**\n * Encryption utility class using AES-GCM encryption\n */\nexport class EncryptionUtils {\n  private key: CryptoKey = {} as CryptoKey;\n  private secretKey: string;\n  private keyGenerated: boolean = false;\n\n  constructor(secretKey: string) {\n    this.secretKey = secretKey;\n  }\n\n  /**\n   * Generate or retrieve cached encryption key\n   */\n  async generateKey(secretKey: string): Promise<void> {\n    if (this.keyGenerated && this.secretKey !== secretKey) {\n      this.keyGenerated = false; // key changed\n    }\n\n    if (this.keyGenerated) {\n      return;\n    }\n    this.secretKey = secretKey;\n    const keyData = await this.deriveKey(secretKey);\n    this.key = await crypto.subtle.importKey('raw', keyData, { name: 'AES-GCM' }, false, [\n      'encrypt',\n      'decrypt',\n    ]);\n    this.keyGenerated = true;\n  }\n\n  /**\n   * Derive encryption key from secret using PBKDF2\n   */\n  private async deriveKey(secretKey: string): Promise<ArrayBuffer> {\n    const encoder = new TextEncoder();\n    const salt = encoder.encode('someSalt'); // Replace 'someSalt' with a suitable salt value\n    const iterations = 100000; // Adjust the number of iterations as needed\n    const keyLength = 256; // 256 bits (32 bytes)\n    const derivedKey = await crypto.subtle.importKey(\n      'raw',\n      encoder.encode(secretKey),\n      { name: 'PBKDF2' },\n      false,\n      ['deriveBits']\n    );\n    return crypto.subtle.deriveBits(\n      {\n        name: 'PBKDF2',\n        salt,\n        iterations,\n        hash: 'SHA-256',\n      },\n      derivedKey,\n      keyLength\n    );\n  }\n\n  /**\n   * Encrypt ArrayBuffer data\n   */\n  async encryptArrayBuffer(data: ArrayBuffer): Promise<ArrayBuffer> {\n    await this.generateKey(this.secretKey);\n\n    const iv = crypto.getRandomValues(new Uint8Array(16)); // Initialization vector\n    const encryptedData = await crypto.subtle.encrypt(\n      {\n        name: 'AES-GCM',\n        iv: iv,\n      },\n      this.key,\n      data\n    );\n    return new Blob([iv, new Uint8Array(encryptedData)]).arrayBuffer(); // Prepend IV to the ciphertext\n  }\n\n  /**\n   * Convert Blob to ArrayBuffer\n   */\n  async blobToArrayBuffer(blob: Blob): Promise<ArrayBuffer> {\n    return new Promise((resolve, reject) => {\n      const reader = new FileReader();\n      reader.onload = () => resolve(reader.result as ArrayBuffer);\n      reader.onerror = reject;\n      reader.readAsArrayBuffer(blob);\n    });\n  }\n\n  /**\n   * Decrypt ArrayBuffer data\n   */\n  async decryptArrayBuffer(encryptedData: ArrayBuffer | Blob): Promise<ArrayBuffer> {\n    try {\n      await this.generateKey(this.secretKey);\n\n      let encryptedArrayBuffer: ArrayBuffer;\n      if (encryptedData instanceof Blob) {\n        encryptedArrayBuffer = await this.blobToArrayBuffer(encryptedData);\n      } else {\n        encryptedArrayBuffer = encryptedData;\n      }\n\n      const iv = new Uint8Array(encryptedArrayBuffer.slice(0, 16)); // Extract the IV\n      const cipherText = encryptedArrayBuffer.slice(16);\n\n      return await crypto.subtle.decrypt(\n        {\n          name: 'AES-GCM',\n          iv: iv,\n        },\n        this.key,\n        cipherText\n      );\n    } catch (e) {\n      console.error('Error decrypting ArrayBuffer', e);\n      // Return the original data cast as ArrayBuffer\n      if (encryptedData instanceof Blob) {\n        return await this.blobToArrayBuffer(encryptedData);\n      }\n      return encryptedData as ArrayBuffer;\n    }\n  }\n\n  /**\n   * Encrypt string text\n   */\n  async encrypt(text: string): Promise<string> {\n    await this.generateKey(this.secretKey);\n\n    const encoder = new TextEncoder();\n    const data = encoder.encode(text);\n    const iv = crypto.getRandomValues(new Uint8Array(16));\n    const encryptedData = await crypto.subtle.encrypt({ name: 'AES-GCM', iv }, this.key, data);\n    const encryptedArray = Array.from(new Uint8Array(encryptedData));\n    const encryptedHex = encryptedArray.map((byte) => byte.toString(16).padStart(2, '0')).join('');\n    const ivHex = Array.from(iv)\n      .map((byte) => byte.toString(16).padStart(2, '0'))\n      .join('');\n    return ivHex + encryptedHex;\n  }\n\n  /**\n   * Decrypt string text\n   */\n  async decrypt(cipherText: string): Promise<string> {\n    try {\n      if (cipherText) {\n        await this.generateKey(this.secretKey);\n\n        const ivHex = cipherText.slice(0, 32);\n        const encryptedHex = cipherText.slice(32);\n        const iv = new Uint8Array(\n          (ivHex.match(/.{1,2}/g) || []).map((byte) => parseInt(byte, 16))\n        );\n        const encryptedArray = new Uint8Array(\n          (encryptedHex.match(/.{1,2}/g) || []).map((byte) => parseInt(byte, 16))\n        );\n\n        const decryptedData = await crypto.subtle.decrypt(\n          { name: 'AES-GCM', iv },\n          this.key,\n          encryptedArray\n        );\n        const decoder = new TextDecoder();\n        return decoder.decode(decryptedData);\n      } else {\n        return cipherText;\n      }\n    } catch (e) {\n      console.error(\n        'Error decoding: ' +\n          (cipherText && cipherText.length > 100\n            ? cipherText.slice(0, 100) + '...'\n            : cipherText),\n        e\n      );\n      return cipherText; // probably the text was not encrypted or in bad ivHex/encryptedHex format\n    }\n  }\n}\n\n/**\n * Generate a random password\n */\nexport function generatePassword(): string {\n  const key = crypto.getRandomValues(new Uint8Array(32));\n  return btoa(String.fromCharCode(...key));\n}\n\n/**\n * DTO encryption filter for encrypting/decrypting object fields\n */\nexport class DTOEncryptionFilter<T> {\n  private utils: EncryptionUtils;\n\n  constructor(secretKey: string) {\n    this.utils = new EncryptionUtils(secretKey);\n  }\n\n  /**\n   * Encrypt specified fields in a DTO\n   */\n  async encrypt(dto: T, encryptionSettings?: DTOEncryptionSettings): Promise<T> {\n    return this.process(dto, encryptionSettings, async (value) => {\n      if (value) {\n        if (typeof value === 'object') {\n          // Check if it's a Date object\n          if (Object.prototype.toString.call(value) === '[object Date]') {\n            value = (value as Date).toISOString();\n          }\n          return 'json-' + (await this.utils.encrypt(JSON.stringify(value)));\n        }\n        return await this.utils.encrypt(value);\n      } else {\n        return value;\n      }\n    });\n  }\n\n  /**\n   * Decrypt specified fields in a DTO\n   */\n  async decrypt(dto: T, encryptionSettings?: DTOEncryptionSettings): Promise<T> {\n    return this.process(dto, encryptionSettings, async (value) => {\n      if (value) {\n        if (typeof value === 'string' && value.startsWith('json-')) {\n          return JSON.parse(await this.utils.decrypt(value.slice(5)));\n        }\n        return await this.utils.decrypt(value);\n      } else {\n        return value;\n      }\n    });\n  }\n\n  /**\n   * Process DTO fields with a transformation function\n   */\n  private async process(\n    dto: T,\n    encryptionSettings: DTOEncryptionSettings | undefined,\n    processFn: (value: string) => Promise<string>\n  ): Promise<T> {\n    const result = {} as T;\n    for (const key in dto) {\n      if (\n        (encryptionSettings && encryptionSettings.encryptedFields.indexOf(key) >= 0) ||\n        (!encryptionSettings && (typeof dto[key] === 'string' || typeof dto[key] === 'object'))\n      ) {\n        result[key] = (await processFn(dto[key] as string)) as any;\n      } else {\n        result[key] = dto[key];\n      }\n    }\n    return result;\n  }\n}\n\n/**\n * Generate SHA-256 hash with salt\n */\nexport async function sha256(message: string, salt: string): Promise<string> {\n  const msgUint8 = new TextEncoder().encode(message + salt); // encode as (utf-8) Uint8Array\n  const hashBuffer = await crypto.subtle.digest('SHA-256', msgUint8); // hash the message\n  const hashArray = Array.from(new Uint8Array(hashBuffer)); // convert buffer to byte array\n  const hashHex = hashArray.map((b) => b.toString(16).padStart(2, '0')).join(''); // convert bytes to hex string\n  return hashHex;\n}\n","/**\n * Quota validation utilities for SaaS mode\n */\n\nimport { SaaSContext, QuotaValidationResult } from './types';\n\n/**\n * Validate token quotas against current usage\n * Returns a validation result with status code and message\n * \n * @param saasContext - SaaS context containing quota and usage information\n * @param isSaaSEnabled - Whether SaaS mode is enabled (default: false)\n * @returns Validation result with message and HTTP status code\n */\nexport function validateTokenQuotas(\n  saasContext: SaaSContext | undefined,\n  isSaaSEnabled?: boolean\n): QuotaValidationResult {\n  if (!isSaaSEnabled) {\n    return { message: 'SaaS is not enabled, quotas are not validated', status: 200 };\n  }\n\n  if (!saasContext?.emailVerified) {\n    return { message: 'You must verify e-mail to use the AI features', status: 403 };\n  }\n\n  if (\n    (saasContext.currentQuota.allowedResults || 0) > 0 &&\n    (saasContext?.currentUsage.usedResults ?? 0) >\n      (saasContext?.currentQuota.allowedResults || 0)\n  ) {\n    return { message: 'You have reached the limit of results', status: 403 };\n  }\n\n  if (\n    (saasContext.currentQuota.allowedSessions || 0) > 0 &&\n    (saasContext.currentUsage.usedSessions ?? 0) >\n      (saasContext.currentQuota.allowedSessions || 0)\n  ) {\n    return { message: 'You have reached the limit of sessions', status: 403 };\n  }\n\n  if (\n    (saasContext.currentQuota.allowedUSDBudget || 0) > 0 &&\n    (saasContext.currentUsage.usedUSDBudget ?? 0) >\n      (saasContext.currentQuota.allowedUSDBudget || 0)\n  ) {\n    return { message: 'You have reached the AI Tokens Limit', status: 403 };\n  }\n\n  return { message: 'All OK!', status: 200 };\n}\n","/**\n * File storage service with locking mechanism\n * \n * Provides file I/O operations with concurrency control using file locks.\n * Supports binary, text, and JSON file operations.\n */\n\nimport { IStorageService } from './types';\n\n// Type-safe way to access Buffer and process without Node.js type dependencies\ndeclare const Buffer: any;\ndeclare const process: any;\n\n/**\n * Storage service for managing file operations with locking\n * \n * Note: This is a framework-agnostic interface. Actual implementations\n * should be provided by the consuming application (e.g., Node.js fs-based,\n * cloud storage, etc.)\n */\nexport class StorageService implements IStorageService {\n  private rootPath: string;\n  private uploadPath: string;\n  private schema: string;\n  private fs: any; // Will be provided by implementation\n  private path: any; // Will be provided by implementation\n\n  constructor(\n    databaseIdHash: string,\n    schema: string,\n    fs: any,\n    path: any,\n    rootPath?: string\n  ) {\n    this.fs = fs;\n    this.path = path;\n    // Use rootPath if provided, otherwise try to get current working directory\n    this.rootPath = rootPath || (typeof process !== 'undefined' && process.cwd ? process.cwd() : '.');\n    this.uploadPath = this.path.join(this.rootPath, 'data', databaseIdHash, schema);\n    this.schema = schema;\n  }\n\n  /**\n   * Ensures that the target directory (uploadPath) exists.\n   */\n  private ensureDirExists(): void {\n    if (!this.fs.existsSync(this.uploadPath)) {\n      this.fs.mkdirSync(this.uploadPath, { recursive: true });\n    }\n  }\n\n  /**\n   * Resolve the absolute path for a particular storage key (file name).\n   */\n  private getFilePath(storageKey: string): string {\n    return this.path.resolve(this.uploadPath, storageKey);\n  }\n\n  /**\n   * Resolve the absolute path for the lock file used by concurrency.\n   */\n  private getLockFilePath(storageKey: string): string {\n    return `${this.getFilePath(storageKey)}.lock`;\n  }\n\n  /**\n   * Simple helper to wait between lock acquisition attempts.\n   */\n  private delay(ms: number): Promise<void> {\n    return new Promise((resolve) => setTimeout(resolve, ms));\n  }\n\n  /**\n   * Acquire an exclusive lock on a file by creating a \".lock\" next to it.\n   */\n  public async acquireLock(\n    storageKey: string,\n    maxAttempts = 50,\n    attemptDelayMs = 100\n  ): Promise<void> {\n    const lockFilePath = this.getLockFilePath(storageKey);\n    let attempts = 0;\n\n    while (this.fs.existsSync(lockFilePath)) {\n      attempts++;\n      if (attempts > maxAttempts) {\n        throw new Error(\n          `Could not acquire lock for \"${storageKey}\" after ${maxAttempts} attempts`\n        );\n      }\n      await this.delay(attemptDelayMs);\n    }\n\n    this.fs.writeFileSync(lockFilePath, '');\n  }\n\n  /**\n   * Release the lock by removing the \".lock\" file.\n   */\n  public releaseLock(storageKey: string): void {\n    const lockFilePath = this.getLockFilePath(storageKey);\n    if (this.fs.existsSync(lockFilePath)) {\n      this.fs.unlinkSync(lockFilePath);\n    }\n  }\n\n  /**\n   * Save a binary attachment from a File object (browser File).\n   */\n  public async saveAttachment(file: File, storageKey: string): Promise<void> {\n    this.ensureDirExists();\n    const arrayBuffer = await file.arrayBuffer();\n    const buffer = new Uint8Array(arrayBuffer);\n    this.fs.writeFileSync(this.getFilePath(storageKey), buffer);\n  }\n\n  /**\n   * Save a binary attachment from a base64 string.\n   */\n  public async saveAttachmentFromBase64(base64: string, storageKey: string): Promise<void> {\n    this.ensureDirExists();\n    // Use Buffer if available (Node.js environment)\n    const buffer = typeof Buffer !== 'undefined' ? Buffer.from(base64, 'base64') : base64;\n    this.fs.writeFileSync(this.getFilePath(storageKey), buffer);\n  }\n\n  /**\n   * Save a plain-text file (UTF-8).\n   */\n  public async savePlainTextAttachment(text: string, storageKey: string): Promise<void> {\n    this.ensureDirExists();\n    this.fs.writeFileSync(this.getFilePath(storageKey), text, 'utf8');\n  }\n\n  /**\n   * Read a plain-text file (UTF-8).\n   */\n  public readPlainTextAttachment(storageKey: string): string {\n    const filePath = this.getFilePath(storageKey);\n    return this.fs.readFileSync(filePath, 'utf8');\n  }\n\n  /**\n   * Check if a file exists.\n   */\n  public fileExists(storageKey: string): boolean {\n    const filePath = this.getFilePath(storageKey);\n    return this.fs.existsSync(filePath);\n  }\n\n  /**\n   * Read a binary attachment as an ArrayBuffer.\n   */\n  public readAttachment(storageKey: string): ArrayBuffer {\n    const filePath = this.getFilePath(storageKey);\n    const buffer = this.fs.readFileSync(filePath);\n    return new Uint8Array(buffer).buffer;\n  }\n\n  /**\n   * Read a binary attachment as a base64 data URI string (with mimeType).\n   */\n  public readAttachmentAsBase64WithMimeType(storageKey: string, mimeType: string): string {\n    const filePath = this.getFilePath(storageKey);\n    const buffer = this.fs.readFileSync(filePath).toString('base64');\n    return `data:${mimeType};base64,${buffer}`;\n  }\n\n  /**\n   * Delete a file by its storage key.\n   */\n  public deleteAttachment(storageKey: string): void {\n    const filePath = this.getFilePath(storageKey);\n    if (this.fs.existsSync(filePath)) {\n      this.fs.rmSync(filePath);\n    }\n  }\n\n  /**\n   * Read a JSON file from disk and parse it. Returns {} if not found.\n   */\n  public readPlainJSONAttachment<T = any>(storageKey: string): T {\n    this.ensureDirExists();\n    const filePath = this.getFilePath(storageKey);\n    if (!this.fs.existsSync(filePath)) {\n      return {} as T;\n    }\n    const raw = this.fs.readFileSync(filePath, 'utf8');\n    return JSON.parse(raw) as T;\n  }\n\n  /**\n   * Writes data as JSON to disk. Checks size against maxFileSizeMB (default 10).\n   */\n  public writePlainJSONAttachment(storageKey: string, data: any, maxFileSizeMB = 10): void {\n    this.ensureDirExists();\n    const jsonString = JSON.stringify(data);\n    // Calculate size (use Buffer if available, otherwise approximate)\n    const size = typeof Buffer !== 'undefined' \n      ? Buffer.byteLength(jsonString, 'utf8')\n      : jsonString.length;\n\n    if (size > maxFileSizeMB * 1024 * 1024) {\n      throw new Error(`File size limit of ${maxFileSizeMB}MB exceeded for ${storageKey}.`);\n    }\n\n    this.fs.writeFileSync(this.getFilePath(storageKey), jsonString, 'utf8');\n  }\n}\n","/**\n * Template rendering engine\n * \n * Supports Jinja2-like syntax:\n * - Variables: {{ variable }}, {{ variable|filter }}\n * - Conditionals: {% if condition %}...{% else %}...{% endif %}\n * - Loops: {% for item in items %}...{% else %}...{% endfor %}\n */\n\nimport { TemplateContext, TemplateFilter, TemplateOptions, ITemplateManager } from './types';\n\n/**\n * Basic HTML-escaper used in the \"|escape\" (or \"|e\") filter.\n */\nfunction escapeHtml(input: any): string {\n  const str = String(input ?? '');\n  return str\n    .replace(/&/g, '&amp;')\n    .replace(/</g, '&lt;')\n    .replace(/>/g, '&gt;')\n    .replace(/\"/g, '&quot;')\n    .replace(/'/g, '&#39;');\n}\n\n/**\n * Retrieve a nested value from context by splitting on \".\"\n * e.g. getValueFromContext(\"user.name\", { user: { name: \"Alice\" } }) -> \"Alice\"\n */\nfunction getValueFromContext(varPath: string, context: any): any {\n  return varPath.split('.').reduce((acc, key) => acc && acc[key], context);\n}\n\n/**\n * Evaluate the condition in {% if condition %}.\n * \n * A very naive approach: if `conditionExpr` is a simple variable path,\n * we get its value from the context and do a truthy check.\n */\nfunction evaluateCondition(conditionExpr: string, context: any): boolean {\n  const value = getValueFromContext(conditionExpr, context);\n  return !!value;\n}\n\n/**\n * Parse if-blocks of the form:\n * \n *    {% if something %}\n *      ...\n *    {% else %}\n *      ...\n *    {% endif %}\n */\nfunction parseIfBlocks(\n  template: string,\n  context: any,\n  filters: Record<string, TemplateFilter>\n): string {\n  const ifBlockRegex = /{%\\s*if\\s+(.+?)\\s*%}([\\s\\S]*?){%\\s*endif\\s*%}/;\n\n  let match = ifBlockRegex.exec(template);\n  while (match) {\n    const [fullMatch, conditionExpr, blockContent] = match;\n\n    // Check for optional {% else %} inside the blockContent\n    let elseContent = '';\n    let thenContent = blockContent;\n\n    const elseRegex = /{%\\s*else\\s*%}([\\s\\S]*)$/;\n    const elseMatch = elseRegex.exec(blockContent);\n    if (elseMatch) {\n      thenContent = blockContent.slice(0, elseMatch.index);\n      elseContent = elseMatch[1];\n    }\n\n    // Evaluate condition\n    const conditionResult = evaluateCondition(conditionExpr, context);\n\n    // If condition is truthy, keep the \"thenContent\"\n    // otherwise, keep the \"elseContent\"\n    let chosenContent = conditionResult ? thenContent : elseContent;\n\n    // Recursively parse nested if-blocks within the chosen content\n    chosenContent = parseIfBlocks(chosenContent, context, filters);\n\n    // Also parse nested for-blocks inside this chunk\n    chosenContent = parseForBlocks(chosenContent, context, filters);\n\n    // And do variable replacement\n    chosenContent = replaceVariables(chosenContent, context, filters);\n\n    // Replace the entire if-block in the template\n    template =\n      template.slice(0, match.index) +\n      chosenContent +\n      template.slice(match.index + fullMatch.length);\n\n    match = ifBlockRegex.exec(template);\n  }\n\n  return template;\n}\n\n/**\n * Parse for-blocks of the form:\n * \n *    {% for user in users %}\n *      ...\n *    {% else %}\n *      ...\n *    {% endfor %}\n */\nfunction parseForBlocks(\n  template: string,\n  context: any,\n  filters: Record<string, TemplateFilter>\n): string {\n  const forBlockRegex = /{%\\s*for\\s+(\\w+)\\s+in\\s+(\\w+(?:\\.\\w+)*)\\s*%}([\\s\\S]*?){%\\s*endfor\\s*%}/;\n\n  let match = forBlockRegex.exec(template);\n  while (match) {\n    const [fullMatch, itemVar, arrayVar, blockContent] = match;\n\n    let elseContent = '';\n    let innerContent = blockContent;\n\n    // Check for optional {% else %} inside the blockContent\n    const elseRegex = /{%\\s*else\\s*%}([\\s\\S]*)$/;\n    const elseMatch = elseRegex.exec(blockContent);\n    if (elseMatch) {\n      innerContent = blockContent.slice(0, elseMatch.index);\n      elseContent = elseMatch[1];\n    }\n\n    // Resolve array from context\n    const arr = getValueFromContext(arrayVar, context) || [];\n    let replacement = '';\n\n    if (Array.isArray(arr) && arr.length > 0) {\n      for (const item of arr) {\n        // Extend context with current item\n        const newContext = { ...context, [itemVar]: item };\n\n        // Recursively parse if/for/variables in the loop content\n        let parsed = innerContent;\n        parsed = parseIfBlocks(parsed, newContext, filters);\n        parsed = parseForBlocks(parsed, newContext, filters);\n        parsed = replaceVariables(parsed, newContext, filters);\n\n        replacement += parsed;\n      }\n    } else if (typeof arr === 'object' && Object.values(arr).length > 0) {\n      for (const item of Object.values(arr)) {\n        // Extend context with current item\n        const newContext = { ...context, [itemVar]: item };\n\n        // Recursively parse if/for/variables in the loop content\n        let parsed = innerContent;\n        parsed = parseIfBlocks(parsed, newContext, filters);\n        parsed = parseForBlocks(parsed, newContext, filters);\n        parsed = replaceVariables(parsed, newContext, filters);\n\n        replacement += parsed;\n      }\n    } else {\n      // If array is empty, parse the else block\n      let parsedElse = elseContent;\n      parsedElse = parseIfBlocks(parsedElse, context, filters);\n      parsedElse = parseForBlocks(parsedElse, context, filters);\n      parsedElse = replaceVariables(parsedElse, context, filters);\n      replacement = parsedElse;\n    }\n\n    // Replace entire block with the loop expansion\n    template =\n      template.slice(0, match.index) +\n      replacement +\n      template.slice(match.index + fullMatch.length);\n\n    match = forBlockRegex.exec(template);\n  }\n\n  return template;\n}\n\n/**\n * Replace variable placeholders of the form:\n * \n *    {{ var }}\n *    {{ var|escape }} or {{ var|e }}\n *    {{ var|someCustomFilter }}\n */\nfunction replaceVariables(\n  template: string,\n  context: any,\n  filters: Record<string, TemplateFilter>\n): string {\n  return template.replace(/\\{\\{\\s*(.*?)\\s*\\}\\}/g, (_, expr) => {\n    // e.g., \"user.name|escape\"\n    const parts = expr.split('|').map((p: string) => p.trim());\n    const varPath = parts.shift() ?? '';\n\n    let value = getValueFromContext(varPath, context) ?? '';\n\n    // Apply each filter if exists\n    for (const filterName of parts) {\n      // If user typed \"|e\", treat as \"|escape\"\n      const fn =\n        filters[filterName] || (filterName === 'e' ? filters['escape'] : undefined);\n      if (typeof fn === 'function') {\n        value = fn(value);\n      }\n    }\n\n    return String(value);\n  });\n}\n\n/**\n * Template manager implementation\n */\nexport class TemplateManager implements ITemplateManager {\n  /**\n   * Render a template string with context\n   */\n  render(template: string, context: TemplateContext, options?: TemplateOptions): string {\n    // Merge built-in filters with custom filters\n    const filters: Record<string, TemplateFilter> = {\n      escape: escapeHtml,\n      e: escapeHtml, // short alias\n      ...(options?.customFilters || {}),\n    };\n\n    // 1) Parse {% if %}\n    template = parseIfBlocks(template, context, filters);\n\n    // 2) Parse {% for %}\n    template = parseForBlocks(template, context, filters);\n\n    // 3) Finally, replace {{ var }} placeholders\n    template = replaceVariables(template, context, filters);\n\n    return template;\n  }\n\n  /**\n   * Render template with a simple function interface\n   */\n  static renderTemplate(\n    template: string,\n    context: TemplateContext,\n    customFilters: Record<string, TemplateFilter> = {}\n  ): string {\n    const manager = new TemplateManager();\n    return manager.render(template, context, { customFilters });\n  }\n}\n\n/**\n * Convenience function to render a template\n */\nexport function renderTemplate(\n  template: string,\n  context: TemplateContext,\n  customFilters: Record<string, TemplateFilter> = {}\n): string {\n  return TemplateManager.renderTemplate(template, context, customFilters);\n}\n","import { nanoid } from 'nanoid';\n\n/**\n * Recursively traverses the given object (and its children via \"input\" and \"item\")\n * updating each node's \"name\" property to reflect the path of agents from the root.\n */\nexport function setRecursiveNames(obj: any, path: string[] = []): void {\n  // Skip if not an object\n  if (!obj || typeof obj !== 'object') {\n    return;\n  }\n\n  if (!obj.id) {\n    obj.id = nanoid();\n  }\n\n  // If this node has an 'agent', extend our path\n  if (typeof obj.agent === 'string') {\n    const newPath = [...path, obj.agent];\n    // Update the node's name to be the full path joined by \" > \"\n    obj.name = newPath.join(' > ');\n\n    // Recursively handle \"input\"\n    if (Array.isArray(obj.input)) {\n      for (const child of obj.input) {\n        setRecursiveNames(child, newPath);\n      }\n    } else if (obj.input && typeof obj.input === 'object') {\n      setRecursiveNames(obj.input, newPath);\n    }\n\n    // Recursively handle \"item\"\n    if (Array.isArray(obj.item)) {\n      for (const child of obj.item) {\n        setRecursiveNames(child, newPath);\n      }\n    } else if (obj.item && typeof obj.item === 'object') {\n      setRecursiveNames(obj.item, newPath);\n    }\n  } else {\n    // Even if there's no 'agent', we should still go deeper if \"input\" or \"item\" exist\n    if (Array.isArray(obj.input)) {\n      for (const child of obj.input) {\n        setRecursiveNames(child, path);\n      }\n    } else if (obj.input && typeof obj.input === 'object') {\n      setRecursiveNames(obj.input, path);\n    }\n\n    if (Array.isArray(obj.item)) {\n      for (const child of obj.item) {\n        setRecursiveNames(child, path);\n      }\n    } else if (obj.item && typeof obj.item === 'object') {\n      setRecursiveNames(obj.item, path);\n    }\n  }\n}\n\n/**\n * Get an object property by JSON path notation (e.g., \"$.user.name\" or \"$.items[0]\")\n * @param obj - The object to traverse\n * @param path - The JSON path string starting with \"$\"\n * @returns The value at the specified path or undefined if not found\n */\nexport function getObjectByPath(obj: any, path: string): any {\n  if (!path.startsWith('$')) {\n    throw new Error(\"Invalid path: Path should start with '$'\");\n  }\n\n  // Regex to split path correctly while keeping array indices\n  const keys = path\n    .replace(/\\[(\\d+)\\]/g, '.$1') // Convert array indices to dot notation (e.g., \"f[2]\"  \"f.2\")\n    .slice(2) // Remove the \"$.\"\n    .split('.');\n\n  let current = obj;\n  for (const key of keys) {\n    if (typeof current !== 'object' || current === null || !current.hasOwnProperty(key)) {\n      return undefined; // Return undefined if path is invalid\n    }\n    current = current[key];\n  }\n\n  return current;\n}\n","import { ZodError, type ZodIssue } from 'zod';\nimport { nanoid } from 'nanoid';\n\ntype ErrorWithMessage = {\n  message: string;\n};\n\nfunction isErrorWithMessage(error: unknown): error is ErrorWithMessage {\n  return (\n    typeof error === 'object' &&\n    error !== null &&\n    'message' in error &&\n    typeof (error as Record<string, unknown>).message === 'string'\n  );\n}\n\nfunction toErrorWithMessage(maybeError: unknown): ErrorWithMessage {\n  if (isErrorWithMessage(maybeError)) return maybeError;\n\n  try {\n    return new Error(JSON.stringify(maybeError));\n  } catch {\n    // fallback in case there's an error stringifying the maybeError\n    // like with circular references for example.\n    return new Error(String(maybeError));\n  }\n}\n\n/**\n * Get error message from any error type\n */\nexport function getErrorMessage(error: unknown): string {\n  return toErrorWithMessage(error).message;\n}\n\n/**\n * Format Zod validation error\n */\nexport function formatZodError(err: unknown): { type: string; message: string; [key: string]: any } {\n  let errorChunk: { type: string; message: string; [key: string]: any } = { \n    type: 'error', \n    message: getErrorMessage(err) \n  };\n\n  if (err instanceof ZodError) {\n    // Format each issue so it's easier to read in one string\n    const formattedIssues = err.issues\n      .map((issue: ZodIssue) => {\n        const path = issue.path.join('.');\n        const code = issue.code;\n        return `Path: **${path}**; Code: **${code}**; Message: **${issue.message}**`;\n      })\n      .join('\\n\\n');\n\n    errorChunk = {\n      flowNodeId: nanoid(),\n      type: 'error',\n      message: formattedIssues,\n    };\n  }\n\n  return errorChunk;\n}\n\n/**\n * Get Zod error message (simple format)\n */\nexport function getZodErrorMessage(error: ZodError): string {\n  return error.errors.map((e: ZodIssue) => e.path[0] + ': ' + e.message).join(', ');\n}\n\n/**\n * Format Axios error (if axios is being used)\n */\nexport function formatAxiosError(error: any): string {\n  if (error.isAxiosError) {\n    const status = error.response?.status || 'Unknown Status';\n    const data = error.response?.data;\n\n    let errorMessage = `HTTP Error ${status}`;\n\n    if (data) {\n      if (typeof data === 'string') {\n        errorMessage += `: ${data}`;\n      } else if (typeof data === 'object') {\n        errorMessage += `: ${JSON.stringify(data, null, 2)}`;\n      }\n    } else {\n      errorMessage += `: ${error.message}`;\n    }\n\n    return errorMessage;\n  }\n\n  return `Unexpected error: ${error instanceof Error ? error.message : String(error)}`;\n}\n","/**\n * Get current timestamp in formatted string\n */\nexport function getCurrentTS(): string {\n  return getTS();\n}\n\n/**\n * Format date to timestamp string (YYYY-MM-DD HH:MM:SS)\n */\nexport function getTS(now = new Date()): string {\n  const year = now.getFullYear();\n  const month = String(now.getMonth() + 1).padStart(2, '0');\n  const day = String(now.getDate()).padStart(2, '0');\n\n  const hours = String(now.getHours()).padStart(2, '0');\n  const minutes = String(now.getMinutes()).padStart(2, '0');\n  const seconds = String(now.getSeconds()).padStart(2, '0');\n\n  const formattedDate = `${year}-${month}-${day} ${hours}:${minutes}:${seconds}`;\n\n  return formattedDate;\n}\n\n/**\n * Format date to locale string\n */\nexport function formatDate(date: Date): string {\n  return date.toLocaleString();\n}\n\n/**\n * Safe JSON parse with default value\n */\nexport function safeJsonParse<T = any>(str: string, defaultValue: T): T {\n  try {\n    return JSON.parse(str);\n  } catch {\n    return defaultValue;\n  }\n}\n\n/**\n * Remove markdown code blocks from text\n */\nexport function removeCodeBlocks(text: string): string {\n  const PATTERN = /^([A-Za-z \\t]*)```([A-Za-z]*)?\\n([\\s\\S]*?)```([A-Za-z \\t]*)*$/gm;\n  return text.replace(PATTERN, '');\n}\n\n/**\n * Count lines in text\n */\nfunction countLines(text = ''): number {\n  return text.split('\\n').length;\n}\n\n/**\n * Get line number from text and regex match\n */\nfunction getLineNumber(text = '', matches: any): number {\n  return countLines(text.substr(0, matches.index));\n}\n\nexport interface CodeBlock {\n  line: number;\n  position: number;\n  syntax: string;\n  block: string;\n  code: string;\n}\n\nexport interface CodeBlockError {\n  line: number;\n  position: number;\n  message: string;\n  block: string;\n}\n\nexport interface CodeBlockResult {\n  errors: CodeBlockError[];\n  blocks: CodeBlock[];\n}\n\n/**\n * Find and extract code blocks from markdown text\n */\nexport function findCodeBlocks(block: string, singleBlockMode = true): CodeBlockResult {\n  const PATTERN = /^([A-Za-z \\t]*)```([A-Za-z]*)?\\n([\\s\\S]*?)```([A-Za-z \\t]*)*$/gm;\n  let matches;\n  const errors: CodeBlockError[] = [];\n  const blocks: CodeBlock[] = [];\n\n  while ((matches = PATTERN.exec(block)) !== null) {\n    if (matches.index === PATTERN.lastIndex) {\n      PATTERN.lastIndex++; // avoid infinite loops with zero-width matches\n    }\n\n    const [match, prefix, syntax, content, postFix] = matches;\n    const lang = syntax || 'none';\n    const lineNumber = getLineNumber(block, matches);\n    let hasError = false;\n\n    /* Validate code blocks */\n    if (prefix && prefix.match(/\\S/)) {\n      hasError = true;\n      errors.push({\n        line: lineNumber,\n        position: matches.index,\n        message: `Prefix \"${prefix}\" not allowed on line ${lineNumber}. Remove it to fix the code block.`,\n        block: match,\n      });\n    }\n\n    if (postFix && postFix.match(/\\S/)) {\n      hasError = true;\n      const line = lineNumber + (countLines(match) - 1);\n      errors.push({\n        line,\n        position: matches.index + match.length,\n        message: `Postfix \"${postFix}\" not allowed on line ${line}. Remove it to fix the code block.`,\n        block: match,\n      });\n    }\n\n    if (!hasError) {\n      blocks.push({\n        line: lineNumber,\n        position: matches.index,\n        syntax: lang,\n        block: match,\n        code: content.trim(),\n      });\n    }\n  }\n\n  if (blocks.length === 0 && singleBlockMode) {\n    blocks.push({\n      line: 0,\n      position: 0,\n      syntax: '',\n      block: '',\n      code: block.trim(),\n    });\n  }\n\n  return {\n    errors,\n    blocks,\n  };\n}\n\n/**\n * Check if API key is provided, throw error if not\n */\nexport function checkApiKey(name: string, key: string, value: string): string {\n  if (value) return value;\n\n  throw new Error(\n    `Please provide the ${name} API key in the environment variable ${key}`\n  );\n}\n","import { z, type ZodSchema } from 'zod';\n\n/**\n * Validate data against a Zod schema\n */\nexport function validateWithSchema<T>(schema: ZodSchema<T>, data: unknown): T {\n  return schema.parse(data);\n}\n\n/**\n * Safe validation that returns result with success flag\n */\nexport function safeValidate<T>(\n  schema: ZodSchema<T>,\n  data: unknown\n): { success: true; data: T } | { success: false; error: z.ZodError } {\n  const result = schema.safeParse(data);\n  if (result.success) {\n    return { success: true, data: result.data };\n  }\n  return { success: false, error: result.error };\n}\n\n/**\n * Check if value is a valid email\n */\nexport function isValidEmail(email: string): boolean {\n  const emailRegex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\n  return emailRegex.test(email);\n}\n\n/**\n * Check if value is a valid URL\n */\nexport function isValidUrl(url: string): boolean {\n  try {\n    new URL(url);\n    return true;\n  } catch {\n    return false;\n  }\n}\n\n/**\n * Check if value is a valid JSON string\n */\nexport function isValidJson(str: string): boolean {\n  try {\n    JSON.parse(str);\n    return true;\n  } catch {\n    return false;\n  }\n}\n\n/**\n * Sanitize string for safe output (basic HTML escape)\n */\nexport function sanitizeString(str: string): string {\n  return str\n    .replace(/&/g, '&amp;')\n    .replace(/</g, '&lt;')\n    .replace(/>/g, '&gt;')\n    .replace(/\"/g, '&quot;')\n    .replace(/'/g, '&#39;');\n}\n\n/**\n * Validate that object has required keys\n */\nexport function hasRequiredKeys<T extends Record<string, any>>(\n  obj: T,\n  requiredKeys: (keyof T)[]\n): boolean {\n  return requiredKeys.every((key) => key in obj && obj[key] !== undefined);\n}\n","/**\n * File extraction and processing utilities\n * Handles conversion of various file formats (PDF, Office docs, etc.) to text or images\n */\n\n// Type-safe way to access Buffer without Node.js type dependencies\ndeclare const Buffer: any;\n\nexport interface ProcessFilesParams {\n  inputObject: Record<string, string | string[]>; // base64 or array of base64\n  pdfExtractText?: boolean; // default false\n}\n\n/**\n * Get MIME type from base64 data URI\n */\nexport function getMimeType(base64Data: string): string | null {\n  // Expecting strings like: data:application/pdf;base64,JVBERi0x...\n  const match = base64Data.match(/^data:([^;]+);base64,/);\n  return match ? match[1] : null;\n}\n\n/**\n * Get file extension from MIME type\n */\nexport function getFileExtensionFromMimeType(mimeType: string): string {\n  const map: Record<string, string> = {\n    'application/pdf': 'pdf',\n    'image/png': 'png',\n    'image/jpeg': 'jpg',\n    'image/jpg': 'jpg',\n    'image/gif': 'gif',\n    'image/webp': 'webp',\n    'image/svg+xml': 'svg',\n    'application/vnd.openxmlformats-officedocument.wordprocessingml.document': 'docx',\n    'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet': 'xlsx',\n    'application/vnd.openxmlformats-officedocument.presentationml.presentation': 'pptx',\n    'text/html': 'html',\n    'text/csv': 'csv',\n    'application/json': 'json',\n    'application/zip': 'zip',\n    'text/markdown': 'md',\n    'text/plain': 'txt',\n  };\n  return map[mimeType] || 'not_convertible';\n}\n\n/**\n * Replace base64 content in strings with a placeholder\n * Useful for logging and debugging without exposing large binary data\n */\nexport function replaceBase64Content(data: string): string {\n  // Remove all base64 encoded content from the \"image\" fields\n  return data.replace(\n    /data:image\\/[a-zA-Z]+;base64,[a-zA-Z0-9+/=]+/g,\n    'File content removed'\n  );\n}\n\n/**\n * Check if buffer contains binary data (non-printable characters)\n */\nexport function isBinaryData(buffer: any): boolean {\n  return buffer.some(\n    (byte: number) =>\n      (byte < 32 && byte !== 9 && byte !== 10 && byte !== 13) || byte === 255\n  );\n}\n\n/**\n * Extract base64 data part from data URI\n */\nexport function extractBase64Data(base64Str: string): string {\n  const parts = base64Str.split(',');\n  if (parts.length < 2) {\n    return base64Str;\n  }\n  return parts[1];\n}\n\n/**\n * Create a data URI from MIME type and base64 data\n */\nexport function createDataUri(mimeType: string, base64Data: string): string {\n  return `data:${mimeType};base64,${base64Data}`;\n}\n","/**\n * Build AI Agent SDK\n * Framework-agnostic SDK for building AI agents\n * \n * @packageDocumentation\n */\n\n// Version\nexport const VERSION = '1.0.0-alpha.8';\n\n// Core exports\nexport * from './core';\n\n// Type exports\nexport * from './types';\n\n// Agent types\nexport * from './agent-types';\n\n// Tools\nexport * from './tools';\n\n// Flows\nexport * from './flows';\n\n// Data\nexport * from './data';\n\n// Providers\nexport * from './providers';\n\n// Execution\nexport * from './execution';\n\n// Security\nexport * from './security';\n\n// Storage\nexport * from './storage';\n\n// Templates\nexport * from './templates';\n\n// Utils\nexport * from './utils';\n"]}